---
id: overview
title: Overview
hide_title: true
---

# Overview

Below is a high level view of the backend SDKs. An SDK can have one or more recipes in them, and may have all or some of the parts that are mentioned below.

## Init
Used to initialise SuperTokens - providing app info, core connection info and a list of recipes to initalise as well.

Initialising means calling `init` in all the recipes and normalising of user configuration.

## API Routing
The user has to add our API handling logic in their API webserver so that we can handle all API requests with `/auth/*` (by default).

For example, in Node & express, this can be done by the user adding `app.use(supertokens.middleware())` in their app. Here all requests will be intercepted by our middleware which will check for the request route, and if any of the recipes that have been initialised can handle them, then they do, else it gets passed on to the user's APIs.

## Recipe Routing
Each recipe can have a set of APIs that they can handle. For example, the session recipe has:
- `/session/refresh POST`
- `/signout POST`

When a request comes in the middlware, we first check the `rid` header in the request to see which recipe it is targetting (based on recipe ID). Then we find that recipe from the `recipeList` provide by the user, and see if the path and method matches any of the APIs they expose. If yes, we let the recipe handle that API request. Else we pass the request to the user's routes.

In the node SDK, this logic can be found [here](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/supertokens.ts#L142) (the `middleware` function in that file).

Sometimes a recipe has sub recipes. In this case, the `rid` of the request would not be a sub recipe's `rid`, but would be the super recipe's `rid`. This way, the super recipe would get to handle this request, and can further check its child recipes for if they can handle it or not.

## Error routing
An error can be thrown during an API or during a function call (which can also be called in the user's API). 

If it's an [unexpected error](../../recipe-design/api-design) (See section 1,2,b) then we let the user's error handler handle the error.

If it's an [expected error](../../recipe-design/api-design) (See section 1,2,a) then we need to handle it to send the right API output. This is where the error routing logic comes into picture.

In order to properly route errors, we need to recognise if an error was generated by the lib or by the user's APIs. In different languages we can approach this in different ways. In Java for example, we can use class names / inheritance to do this. In Javascript, we need to use something else like some random "magic" value as seen [here](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/error.ts#L17) - if an error contains this value, it's by us.

Once we have deduced that this error is by us, we ask each recipe if they generated it, and if yes, we let them handle it. Else we pass it to the user's error handler. This logic can be seen [here](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/supertokens.ts#L209) (`errorHandler` function in that file).

## Integrating with various web frameworks
TODO:

## Recipes
### Init
Is called during SDK initialisation. Here we: 
- Normalise user config for this recipe
- Create an instance of the recipe implementation and pass it to the override function (in case the user has given one).
- Create an instance of the API implementation and pass it to the override function (in case the user has given one).
- Create instances of any sub recipes that this recipe needs.

### Recipe Interface
A recipe interface is an interface that defines all the "core" functions that this recipe logic / APIs can depend on. 

For example, for the emailpassword recipe, we would have at least these three functions:
- `signUp`
- `signIn`
- `doesEmailExist`

You can find the full interface for the emailpassword recipe [here](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/emailpassword/types.ts#L203).

This recipe would need to use other recipes like the `emailverification` or the `session` recipe, and those would have their own recipe interface.

### API Interface
An API interface is an interface that is one to one mapped with the different APIs being exposed by a recipe. So if a recipe has two APIs, there will be two functions in its API interface, and those APIs will do input validation / extraction and then call their respective API interface functions.

For example, for the emailpassword recipe, we would have at least these functions:
- `emailExistsGET`
- `signInPOST`
- `signUpPOST`

You can find the full interface for the emailpassword recipe [here](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/emailpassword/types.ts#L256).

This recipe would need to use other recipes like the `emailverification` or the `session` recipe, and those would have their own API interface.








-------------------------






### Recipe implementation
A recipe implementation is a class that implements the recipe interface for a recipe. This recipe implementation is the default behaviour of that recipe.

You can find the recipe implementation of the `emailpassword` recipe [here](https://github.com/supertokens/supertokens-auth-react/blob/master/lib/ts/recipe/emailpassword/recipeImplementation.ts).

Most functions in the recipe implementation usually just query the backend as per the FDI spec and return the result. However, sometimes, they can have very complex logic (as is the case with the `session` recipe - see [here](https://github.com/supertokens/supertokens-website/blob/master/lib/ts/recipeImplementation.ts)).

### Overriding the recipe implementation
We allow users to override the default recipe implementation so that they can customise the behaviour of the SDK as per their auth requirements.

They can do so by providing the implementation of the following function during the `init` call for that recipe:
```tsx
// an example of how they would override the 
// signUp function of the emailpassword recipe impl
supertokens.init({
    recipeList: [
        EmailPassword.init({
            override {
                functions: (originalImplementation: RecipeInterface): RecipeInterface => {
                    return {
                        ...originalImplementation,
                        signUp: (input) => {
                            // some custom logic
                            // OR
                            return originalImplementation.signUp(input);
                        }
                    }
                };
            }
        });
    ]
});
```

Here, the `originalImplementation` is an instance of the recipe implementation of that recipe. However, it is typed as the recipe interface. This allows composability of recipe interfaces - for example, one implementation of the recipe interface can add feature X, and another can add feature Y. The user can use both and get X and Y!

### Feature React components
These are logical components that have no UI. Their job is to use the recipe implementation (either the default one or overriden one) to prepare props in a way that the theme components can use them.

An example of this can be found [here](https://github.com/supertokens/supertokens-auth-react/blob/master/lib/ts/recipe/emailpassword/components/features/signInAndUp/index.tsx).

### Wrapper React components
These are higher order react components that use a recipe to provide some functionality. For example, the [`SessionAuth` component](https://github.com/supertokens/supertokens-auth-react/blob/master/lib/ts/recipe/session/sessionAuth.tsx) uses the session recipe to provide a react context to its children. This context can then be read by them to get information about the session (in a very simple way).

### Theme React components
These are mostly UI only components, receiving props from the feature components. They may have some logic, but it would mostly be for the purpose of driving the UI it displays.

Therefore, a complete UI widget comprises of:
```jsx
<FeatureComponent>
    <ThemeComponent />
</FeatureComponent>
```

### Overriding the theme react components
Just like recipe functions override, the user can override named components in the theme component tree. This allows users to customise the UX / UI of the widgets shown. The level of granuality that they can override depends on how many and which components we allow them to override.

For example, if a theme component is:
```jsx
<EmailPasswordSignInContainer>
    <EmailPasswordHeader />
    <FormContainer />
    <EmailPasswordFooter />
</EmailPasswordSignInContainer>
```

And we allow users to override `EmailPasswordSignInContainer`, `EmailPasswordHeader` and `EmailPasswordSignInContainer`, then the only way they can change `FormContainer` is by overrifing `EmailPasswordSignInContainer`.

The way they can override is:

```tsx
// an example of how they would override the 
// signUp function of the emailpassword recipe impl
supertokens.init({
    recipeList: [
        EmailPassword.init({
            override {
                components: {
                    EmailPasswordFooter: ({OriginalComponent, ...props}) => {
                        return (
                            <>
                            <SomeCustomComponent />
                            <OriginalComponent />
                            </>
                        );
                    }
                }
            }
        });
    ]
});
```

Here the `OriginalComponent` is the original `EmailPasswordFooter` component which the user may or may not decide to use.

### User facing functions
These are functions that are meant for users to use. They usually reside in the `index.ts` file of a recipe or the whole lib.

Examples of functions are:
- `Session.doesSessionExist()`
- `EmailPassword.isEmailVerified()`

These functions usually just call the recipe's underlying (one or several) recipe implementation's function.

Some of them, like the `isEmailVerified` can use a recipe's sub recipe. In this case, `EmailPassword.isEmailVerified()` uses the emailverification recipe that is created inside the emailpassword recipe. This is done because from the user's point of view, they are not directly aware of the emailverification recipe since they only did EmailPassword.init.

There are also some functions that are not tied to a recipe like:
- `supertokens.init`
- `supertokens.canHandleRoute`

## Styling
For the supertokens-auth-react SDK, we use the [@emotion/react](https://emotion.sh/docs/introduction#react) library which allows us to:
- Write CSS in JS
- Allows the user to provide a JS object which can override our default CSS
- Create randomised class names so that our CSS doesn't conflict with the user's CSS (but the other way around is possible).

The user provided JS object (to override our CSS), is exposed to all the theme components via the style context object (usin the react context feature).

Finally, we use a shadow DOM so that the user's CSS doesn't interfere with our CSS - however, this also prevents password managers from working in our forms. So we give users the ability to disable this (across all our components).

## Querying the backend
For our recipes to work, they need to query the users backend which exposes the FDI APIs (via our backend SDK). This querying happens using `fetch`, inside the recipe implementation functions.

For us to know where the user's backend is (which domain and path), the user provides us with an `appInfo` object during initialisation that contains the `apiDomain` and `apiBasePath` values.

## User facing hook functions
Each recipe has three hook functions:
- `onHandleEvent`: A user can give this function to get events for user actions. For example, if the end user signs in, a corresponding event is fired using this function.
- `preAPIHook`: A user can give this function to change the request that is sent to the backend. They can use this to add custom headers / change the path / add custom params etc..
- `getRedirectionURL`: This can be used to change how routing works in a recipe. As an example, if one wants to change where the end user goes post login, they can provide this callback.

## Export paths
The import statements we expose are very important.

For example, the place where all the ts files are built in the supertokens-auth-react SDK is `/lib/build/*`. Therefore, by default, the user would have to use `import ... from "supertokens-auth-react/lib/build/recipe/..."` which is ugly. 

So we have extra files in the lib which allow users to import like `import ... from "supertokens-auth-react/recipe/..."`. As an example, you can see how this is achieved [here](https://github.com/supertokens/supertokens-auth-react/tree/master/recipe). The files in this folder don't have any recipe logic - they simply import / export the actual recipe `index.ts` files.