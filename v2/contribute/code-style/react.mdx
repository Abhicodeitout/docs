---
id: react
title: React
hide_title: true
---

# React

## General advice 

- Remember to add the JSX pragma and import
- Prefer adding components as `const X: React.FC<PropType> = ` instead of a function returning `JSX.Element`
- When using `useEffect`:
    - If it depends on certain variables inside an object, do not make that object a dependency in the array. Instead, extract the variable from the object before the use effect, and put that variable in the dependency array.
    - If you want it to run it just once (similar to `componentDidMount`), provide it an empty dependency array.
    - If applicable, make sure to return a function that runs in case the dependency array has changed (or the component is unmounting). In this function, you can tell the `useEffect` logic to not change state for example (in case there is an `async / await` operation happening in it.)

- Refrain from returning a component from a function. Instead, make that function itself a functional component. This will prevent that component from unmounting and mounting during rerenders. If you must return a component from a function, then the consumer of that function should use `useRef` or `useMemo`.

## Feature and Theme components

Complex functionality should be implemented in feature components and theme components should only have local, simple, and strictly UI-related states. Some examples:

### Feature component state:
- Information that is created in one step of the process and used in another. I.e., `loginAttemptInfo` in passwordless sign in/up
- General error displayed in the sign-in screen but set in the form submit method

### Theme component state:
- Current value of each form field
- Time left until another retry is allowed

### `useReducer`

You should use a reducer to manage the state of a feature component if:
- The state is complex (i.e.: more than a single error and/or status field)
- The feature component functionality will be extracted into a custom hook and reused elsewhere.
- If other similar feature components need to use a reducer. It's better to be consistent. (e.g.: sign in/up feature components of different auth recipes)

If you used a reducer to manage the state you should:
- Move both state and action types into `types.ts` of the recipe.
- The "root" theme component should receive them as `featureState` and `dispatch`. Further down the component tree, they are usually event handlers and individual state variables.
- Check out other components for naming conventions, keeping in mind that it can be renamed if it's imported elsewhere

### Reusable feature components

If the logic of the feature component is reused (i.e.: the corresponding "root" theme component is used in multiple places), it should be extracted into custom hooks. In most cases, these should be `useFeatureReducer` and `useChildProps`.

Keep in mind, that some of these custom hooks may be called without the recipe (e.g.: useChildProps of the sign-in/up feature components in all auth recipes). In this case, it should:
- still work (returning undefined is fine)
- call the same hooks, to not violate the rules of hooks
- be typed in a way so that the return value is defined if the recipe is also defined.
