---
id: "0002"
title: Combining statically and dynamically configured provider list
hide_title: true
---

import DecisionHeader from "/src/components/decisionLogs/DecisionHeader"
import ArgumentPro from "/src/components/decisionLogs/ArgumentPro"
import ArgumentCon from "/src/components/decisionLogs/ArgumentCon"
import ArgumentNeut from "/src/components/decisionLogs/ArgumentNeut"

# Combining statically and dynamically configured provider list

<DecisionHeader status="proposed" lastUpdate="2022-12-08" created="2022-12-08" deciders={["rishabhpoddar", "sattvikc"]} proposedBy={["sattvikc"]} />

## Context and Problem Statement

Since we now allow users to dynamically add provider configurations into the core, and also the user might have configured a static list, this causes an ambiguity on what should be the final set of providers list and which configs should be used by the SDK

How do we come up with a consolidated list of providers and their configs?

## Considered Options

* Prioritize list from the core, merge the config on to the static list prioritizing the config from core. (Refer the option section for more details)


## Decision Outcome

Chosen option: **Prioritize list from the core, merge the config on to the static list prioritizing the config from core.**, because

* Gives complete control on the provider list
* Allows for overrides using the static list
* Allows adding new providers without code change

## Pros and Cons of the Options

### Prioritize list from the core, merge the config on to the static list prioritizing the config from core.

In this approach, if the provider list from core database is empty, we use the static provider list as is.

If the provider list from core database is not empty, we use that list and for each provider in the list:
  - if the same provider is present in the static list, we merge the dynamic and static config, keeping dynamic config as the priority (explained later)
  - if the provider is not present in the static list, then
    - if the provider is an built-in provider, we create an appropriate provider instance
    - else we create a custom provider

In case a certain provider needs an override, but should not be shown for the default tenant (from the static list), an optional config `UseForDefaultTenant` needs to be set to false.


<ArgumentPro> Allows complete replacement of static config list for each tenant </ArgumentPro>
<ArgumentPro> All common configs can be statically declared and only the tenant specific configs can be added to the core. </ArgumentPro>
<ArgumentCon> Needs additional config on the static list to hide, if declared only for override reasons </ArgumentCon>


## Details on the merging, when usesDynamicLoginMethods is true

### Frontend

1. If the static list is empty, dynamic list is not

Using the dynamic list, we create a list of buttons for each provider. For built-in providers, we use the specific button, else a custom button

2. If static list is not empty and the dynamic list is empty

We use the static list as is

3. If both static and dynamic list are not empty and has overlapping providers

  a. We ignore the providers which is not in the dynamic list

  b. For providers which are on both the lists, we use the statically defined config (which may include button customizations)

  c. For the providers which are only on the dynamic list, we either create built-in button or the custom button

### Backend

Similar approach is taken on the backend while determining the final provider list.
Additionally, we prioritise config coming from the core as shown below:

** Merging of clients **

Clients array is merged based on the clientType, prioritising the core

if the static config has following properties:

```json
{
  thirdPartyId: "google",
  clients: [
    {
      clientType: "web",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
    {
      clientType: "mobile",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
  ]
}
```

and the core has the following stored:

```json
{
  thirdPartyId: "google",
  clients: [
    {
      clientType: "web",
      clientId: "clientid_tenant1",
      clientSecret: "clientsecret_tenant1"
    },
  ]
}
```

The final config in use would be:

```json
{
  thirdPartyId: "google",
  clients: [
    {
      clientType: "web",
      clientId: "clientid_tenant1",
      clientSecret: "clientsecret_tenant1"
    },
    {
      clientType: "mobile",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
  ]
}
```

** Merging of other properties **

Other properties are merged based on the key, prioritising the core

if the static config has following properties:

```json
{
  thirdPartyId: "custom",
  clients: [
    {
      clientType: "web",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
    {
      clientType: "mobile",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
  ],
  tokenEndpoint: 'https://example.com/oauth2/token',
}
```

and the core has the following stored:

```json
{
  thirdPartyId: "custom",
  authorizationEndpoint: 'https://anotherexample.com/oauth2/authorize',
  tokenEndpoint: 'https://anotherexample.com/oauth2/token',
}
```

the final config will be:
```json
{
  thirdPartyId: "custom",
  clients: [
    {
      clientType: "web",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
    {
      clientType: "mobile",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
  ],
  authorizationEndpoint: 'https://anotherexample.com/oauth2/authorize',
  tokenEndpoint: 'https://anotherexample.com/oauth2/token',
}
```
