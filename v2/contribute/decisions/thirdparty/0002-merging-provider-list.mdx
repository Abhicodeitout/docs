---
id: "0002"
title: Merge providers list from static config and database
hide_title: true
---

import DecisionHeader from "/src/components/decisionLogs/DecisionHeader"
import ArgumentPro from "/src/components/decisionLogs/ArgumentPro"
import ArgumentCon from "/src/components/decisionLogs/ArgumentCon"
import ArgumentNeut from "/src/components/decisionLogs/ArgumentNeut"

# Merge providers list from static config and database

<DecisionHeader status="proposed" lastUpdate="2022-12-08" created="2022-12-08" deciders={["rishabhpoddar", "sattvikc"]} proposedBy={["sattvikc"]} />

## Context and Problem Statement

How do we select the providers list when the user has configured a list of providers in the static config as well as in the core database? Applicable both on frontend and backend.


## Considered Options

* All providers declared statically
* List from database if available, else static list


## Decision Outcome

Chosen option: **List from database if available, else static list**, because

* Gives complete control on the provider list
* Allows for overrides from the static list

In this approach, if the list from core database is empty, we return the static list.

If the list from core database is not empty, we use that list and for each provider in the list:
  - if the same provider is present in the static list, we merge the dynamic and static config, keeping dynamic config as the priority
  - if the provider is not present in the static list, then
    - if the provider is an built-in provider, we create an appropriate provider instance
    - else we create a custom provider

In case a certain provider needs an override, but should not be shown for the default tenant (from the static list), an optional config `UseForDefaultTenant` needs to be set to false.


## Pros and Cons of the Options

### All providers declared statically

<ArgumentPro> Clear in terms of which providers are in use </ArgumentPro>
<ArgumentCon> Difficult to hide ones in the static list </ArgumentCon>
<ArgumentCon> Does not allow dynamically adding new providers without code change </ArgumentCon>

### List from database if available, else static list

<ArgumentPro> Allows complete replacement of static config list </ArgumentPro>
<ArgumentPro> Intutively, static list can be used with the default tenant, and dynamic list for other tenants </ArgumentPro>
<ArgumentCon> Same config might be duplicated on multiple tenants </ArgumentCon>
<ArgumentCon> Needs additional config on the static list to hide, if declared only for override reasons </ArgumentCon>


## Details on the merging, when usesDynamicLoginMethods is true

### Frontend

1. If the static list is empty, dynamic list is not

Using the dynamic list, we create a list of buttons for each provider. For built-in providers, we use the specific button, else a custom button

2. If static list is not empty and the dynamic list is empty

We use the static list as is

3. If both static and dynamic list are not empty and has overlapping providers

  a. We ignore the providers which is not in the dynamic list

  b. For providers which are on both the lists, we use the statically defined config (which may include button customizations)

  c. For the providers which are only on the dynamic list, we either create built-in button or the custom button

### Backend

Similar approach is taken on the backend while determining the final provider list.
Additionally, we prioritise config coming from the core as shown below:

** Merging of clients **

Clients are merged based on the clientType, prioritising the core

if the static config has following properties:

```json
{
  thirdPartyId: "google",
  clients: [
    {
      clientType: "web",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
    {
      clientType: "mobile",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
  ]
}
```

and the core has the following stored:

```json
{
  thirdPartyId: "google",
  clients: [
    {
      clientType: "web",
      clientId: "clientid_tenant1",
      clientSecret: "clientsecret_tenant1"
    },
    {
      clientType: "mobile",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
  ]
}
```

The final config in use would be:

```json
{
  thirdPartyId: "google",
  clients: [
    {
      clientType: "web",
      clientId: "clientid_tenant1",
      clientSecret: "clientsecret_tenant1"
    },
  ]
}
```

** Merging of other properties **

Other properties are merged based on the key, prioritising the core

if the static config has following properties:

```json
{
  thirdPartyId: "custom",
  clients: [
    {
      clientType: "web",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
    {
      clientType: "mobile",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
  ],
  tokenEndpoint: 'https://example.com/oauth2/token',
}
```

and the core has the following stored:

```json
{
  thirdPartyId: "custom",
  authorizationEndpoint: 'https://anotherexample.com/oauth2/authorize',
  tokenEndpoint: 'https://anotherexample.com/oauth2/token',
}
```

the final config will be:
```json
{
  thirdPartyId: "custom",
  clients: [
    {
      clientType: "web",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
    {
      clientType: "mobile",
      clientId: "clientid1",
      clientSecret: "clientsecret1"
    },
  ],
  authorizationEndpoint: 'https://anotherexample.com/oauth2/authorize',
  tokenEndpoint: 'https://anotherexample.com/oauth2/token',
}
```
