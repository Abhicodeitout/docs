---
id: "0007"
title: Session verification should allow fallback if auth mode header not set
hide_title: true
---

import DecisionHeader from "/src/components/decisionLogs/DecisionHeader"
import ArgumentPro from "/src/components/decisionLogs/ArgumentPro"
import ArgumentCon from "/src/components/decisionLogs/ArgumentCon"
import ArgumentNeut from "/src/components/decisionLogs/ArgumentNeut"

# Session verification should allow fallback if auth mode header not set

<DecisionHeader status="proposed" lastUpdate="2022-10-25" created="2022-10-25" deciders={["rishabhpoddar", "porcellus"]} proposedBy={["porcellus"]} />

## Context and Problem Statement

If the FE sends a request using the wrong authentication method (e.g.: using headers instead of cookies), it could mean:
1. There is an old session present on the FE
2. Our SDK is outdated on the FE
3. Manual requests (SSR)
4. Postman without appropriate headers

Depends on default auth mode decision [0003](./0003)

Example usecases:
- Browser w/ SDK
- ~~Browser w/ old SDK~~ (we require sync update of FE and BE)
- ~~Browser wo/ SDK~~ (we are not optimizing for this, but basically the same as Postman)
- Mobile apps w/ SDK
- Mobile apps wo/ SDK
- CLI
- M2M
- ~~SSR (same as M2M)~~
- Postman (basically CLI w/ cookie storage)
- ~~Native/desktop apps~~ (same as mobile apps)
- ~~E2E testing~~ (Same as mobile without SDK)
- ~~Browser extension w/ SDK~~ (same as browser w/ SDK + some customization)
- Migration (from other services using `Authorization` header with a JWT)

These can be reduced to two things:
- Access to our FE SDK
- Built-in cookie support

## Considered Options

* Reject
* Allow fallback
* Allow fallback if rid header not set
* Allow fallback if auth mode header not set

## Decision Outcome

Allow fallback if auth mode header not set.
- Fallback meaning: cookie first then headers. 
- If idRefreshToken is present, we can also reject with a 401.
- `getTokenTransferMethod` return type will include "MISSING_AUTH_HEADER" that allows fallback

## Pros and Cons of the Options

### Reject

<ArgumentPro> Easier to communicate - if it doesn't match we reject </ArgumentPro>
<ArgumentPro> Always forces upgrade on next request </ArgumentPro>
<ArgumentPro> Strictly matches settings </ArgumentPro>
<ArgumentCon> Cookie based requests without our SDKs need to set preference/rid in header, but this is less used </ArgumentCon>
<ArgumentNeut> With access to our (client) SDK all cases work equally well provided sensible default </ArgumentNeut>

### Allow fallback

<ArgumentPro> Easier to communicate </ArgumentPro>
<ArgumentCon> Can be counter-intuitive: an auth method is set but we don't always respect it </ArgumentCon>
<ArgumentNeut> With access to our (client) SDK all cases work equally well provided sensible default </ArgumentNeut>

### Allow fallback if rid header not set

<ArgumentCon> Harder to communicate - the seemingly unrelated rid header changes things </ArgumentCon>
<ArgumentNeut> With access to our (client) SDK all cases work equally well provided sensible default </ArgumentNeut>


### Allow fallback if auth mode header not set

<ArgumentPro> Easier to communicate </ArgumentPro>
<ArgumentCon> We should still make the backend be able to validate it </ArgumentCon>
<ArgumentNeut> With access to our (client) SDK all cases work equally well provided sensible default </ArgumentNeut>