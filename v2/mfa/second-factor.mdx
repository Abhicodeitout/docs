---
id: second-factor
title: "Setting up the second factor (backend)"
hide_title: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import TabItem from '@theme/TabItem';
import NodeJSFrameworkSubTabsServerless from "/src/components/tabs/NodeJSFrameworkSubTabsServerless"
import GoFrameworkSubTabs from "/src/components/tabs/GoFrameworkSubTabs"
import PythonFrameworkSubTabs from "/src/components/tabs/PythonFrameworkSubTabs"
import BackendSDKCasing from "/src/components/BackendSDKCasing"
import AppInfoForm from "/src/components/appInfoForm"
import CoreInjector from "/src/components/coreInjector"

# Setting up the 2nd factor (backend)

## 1) Initialisation

We will be using the [Passwordless recipe](https://supertokens.com/docs/passwordless/introduction) with SMS OTP as the second factor. You can follow the recipe's [backend quick setup guide](https://supertokens.com/docs/passwordless/quick-setup/backend) to configure a different method as well (for example with email magic links).

The `Passwordless.init` function should look something like this:

<AppInfoForm
    askForAppName
    askForAPIDomain
    askForWebsiteDomain
>

<CoreInjector>

<BackendSDKTabs>
<TabItem value="nodejs">

<NodeJSFrameworkSubTabsServerless>
<TabItem value="express">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "express",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/thirdpartyemailpassword/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({/*Override from previous step*/})
    ]
});
```
</TabItem>

<TabItem value="hapi">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "hapi",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/session/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({ /*Override from previous step*/ })
    ]
});
```
</TabItem>

<TabItem value="fastify">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "fastify",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/session/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({/*Override from previous step*/})
    ]
});
```
</TabItem>

<TabItem value="koa">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "koa",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/session/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({/*Override from previous step*/})
    ]
});
```
</TabItem>

<TabItem value="loopback">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "loopback",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/session/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({/*Override from previous step*/})
    ]
});
```
</TabItem>
<TabItem value="serverless">

:::important
Please refer the **Serverless Deployment** section in the Passwordless recipe guide
:::

</TabItem>
<TabItem value="nextjs">

:::important
Please refer the **NextJS** section in the Passwordless recipe guide
:::

</TabItem>
<TabItem value="nestjs">

:::important
Please refer the **NestJS** section in the Passwordless recipe guide
:::

</TabItem>
</NodeJSFrameworkSubTabsServerless>
</TabItem>
<TabItem value="go">

```go
import (
    "github.com/supertokens/supertokens-golang/recipe/passwordless"
	"github.com/supertokens/supertokens-golang/recipe/passwordless/plessmodels"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword/tpepmodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
    apiBasePath := "^{form_apiBasePath}"
    websiteBasePath := "^{form_websiteBasePath}"
	err := supertokens.Init(supertokens.TypeInput{
		Supertokens: &supertokens.ConnectionInfo{
            ^{coreInjector_connection_uri_comment}
            ConnectionURI: ^{coreInjector_uri}
            ^{coreInjector_api_key_commented}APIKey: ^{coreInjector_api_key},
		},
		AppInfo: supertokens.AppInfo{
            AppName: "^{form_appName}",
            APIDomain: "^{form_apiDomain}",
            WebsiteDomain: "^{form_websiteDomain}",
            APIBasePath: &apiBasePath,
            WebsiteBasePath: &websiteBasePath,
		},
		RecipeList: []supertokens.Recipe{
            // highlight-start
            passwordless.Init(plessmodels.TypeInput{
                FlowType: "USER_INPUT_CODE",
                ContactMethodPhone: plessmodels.ContactMethodPhoneConfig{
                    Enabled: true,
                },
            }),
            // highlight-end
			thirdpartyemailpassword.Init(&tpepmodels.TypeInput{/*...*/}),
			session.Init(&sessmodels.TypeInput{
				/*Override from previous step*/
			}),
		},
	})

	if err != nil {
		panic(err.Error())
	}
}
```
</TabItem>
<TabItem value="python">
<PythonFrameworkSubTabs>
<TabItem value="fastapi">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import thirdpartyemailpassword, session, passwordless
from supertokens_python.recipe.passwordless import ContactPhoneOnlyConfig

init(
    app_info=InputAppInfo(
        app_name="^{form_appName}",
        api_domain="^{form_apiDomain}",
        website_domain="^{form_websiteDomain}",
        api_base_path="^{form_apiBasePath}",
        website_base_path="^{form_websiteBasePath}"
    ),
    supertokens_config=SupertokensConfig(
        ^{coreInjector_connection_uri_comment_with_hash}
        connection_uri=^{coreInjector_uri}
        ^{coreInjector_api_key_commented_with_hash}api_key=^{coreInjector_api_key}
    ),
    framework='fastapi',
    recipe_list=[
	    session.init(), # contains the override from the previous step
        thirdpartyemailpassword.init(
           # ...
        ),
        # highlight-start
        passwordless.init(
            flow_type="USER_INPUT_CODE",
            contact_config=ContactPhoneOnlyConfig()
        )
        # highlight-end
    ],
    mode='asgi' # use wsgi if you are running using gunicorn
)
```

</TabItem>
<TabItem value="flask">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import thirdpartyemailpassword, session, passwordless
from supertokens_python.recipe.passwordless import ContactPhoneOnlyConfig

init(
    app_info=InputAppInfo(
        app_name="^{form_appName}",
        api_domain="^{form_apiDomain}",
        website_domain="^{form_websiteDomain}",
        api_base_path="^{form_apiBasePath}",
        website_base_path="^{form_websiteBasePath}"
    ),
    supertokens_config=SupertokensConfig(
        ^{coreInjector_connection_uri_comment_with_hash}
        connection_uri=^{coreInjector_uri}
        ^{coreInjector_api_key_commented_with_hash}api_key=^{coreInjector_api_key}
    ),
    framework='flask',
    recipe_list=[
	    session.init(), # contains the override from the previous step
        thirdpartyemailpassword.init(
           # ...
        ),
        # highlight-start
        passwordless.init(
            flow_type="USER_INPUT_CODE",
            contact_config=ContactPhoneOnlyConfig()
        )
        # highlight-end
    ]
)
```

</TabItem>
<TabItem value="django">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import thirdpartyemailpassword, session, passwordless
from supertokens_python.recipe.passwordless import ContactPhoneOnlyConfig

init(
    app_info=InputAppInfo(
        app_name="^{form_appName}",
        api_domain="^{form_apiDomain}",
        website_domain="^{form_websiteDomain}",
        api_base_path="^{form_apiBasePath}",
        website_base_path="^{form_websiteBasePath}"
    ),
    supertokens_config=SupertokensConfig(
        ^{coreInjector_connection_uri_comment_with_hash}
        connection_uri=^{coreInjector_uri}
        ^{coreInjector_api_key_commented_with_hash}api_key=^{coreInjector_api_key}
    ),
    framework='django',
    recipe_list=[
	    session.init(), # contains the override from the previous step
        thirdpartyemailpassword.init(
           # ...
        ),
        # highlight-start
        passwordless.init(
            flow_type="USER_INPUT_CODE",
            contact_config=ContactPhoneOnlyConfig()
        )
        # highlight-end
    ],
    mode='asgi' # use wsgi if you are running django server in sync mode
)
```

</TabItem>
</PythonFrameworkSubTabs>
</TabItem>
</BackendSDKTabs>
</CoreInjector>
</AppInfoForm>

The above will expose all the APIs to the frontend that can be used to create and verify the OTP.

## 2) Saving the user's phone number post second factor auth

During sign up, once the user has completed the second factor, we want to save their phone number against their profile. For this, we will use the `UserMetadata` recipe.

:::important
Make sure to add the User Metadata in the recipe list.
:::

The passwordless recipe will create a new `userId` for the user against which it will save the phone number. We can associate the passwordless `userId` with the `userId` of the first factor, and this way, we associate a phone number to the user:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Passwordless.init({
    flowType: "USER_INPUT_CODE",
    contactMethod: "PHONE",
    override: {
        apis: (oI) => {
            return {
                ...oI,
                // this API is called when the user enters the OTP
                consumeCodePOST: async function (input) {
                    // we should already have a session here since this is called
                    // after first factor login
                    let session = await Session.getSession(input.options.req, input.options.res);
                    
                    let resp = await oI.consumeCodePOST!(input);

                    if (resp.status === "OK") {
                        // OTP verification was successful. We can now associate 
                        // the passwordless user ID with the thirdpartyemailpassword
                        // user ID, so that later on, we can fetch the phone number.
                        await UserMetadata.updateUserMetadata(
                            session!.getUserId(), // this is the userId of the first factor login
                            {
                                passwordlessUserId: resp.user.id,
                            }
                        );
                    }

                    return resp;
                },
            };
        },
    }
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">
TODO
</TabItem>
</BackendSDKTabs>

## 3) Updating the session post second factor auth

We also want to change the session's payload to indicate that the user has completed the second factor. In our example, we do this by setting the `is2faComplete` property to `true` in the session's access token payload.

We also have to be careful about not creating a new session after the second factor auth is completed. By default, the passwordless recipe will create a new session on successul verification, overwriting the older one. We can do this by using the `userContext` feature:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Passwordless.init({
    flowType: "USER_INPUT_CODE",
    contactMethod: "PHONE",
    override: {
        apis: (oI) => {
            return {
                ...oI,
                // this API is called when the user enters the OTP
                consumeCodePOST: async function (input) {
                    // we should already have a session here since this is called
                    // after first factor login
                    let session = await Session.getSession(input.options.req, input.options.res);
                    
                    // highlight-start
                    // we add the existing session to the user context so that the createNewSession
                    // function doesn't create a new session
                    input.userContext.session = session;
                    // highlight-end

                    let resp = await oI.consumeCodePOST!(input);

                    if (resp.status === "OK") {
                        // highlight-start
                        // OTP verification was successful. We can now mark the
                        // session's payload as is2faComplete: true so that
                        // the user has access to API routes and the frontend UI
                        await resp.session.updateAccessTokenPayload({
                            ...resp.session.getAccessTokenPayload(),
                            is2faComplete: true,
                        });
                        // highlight-end

                        // We can now associate 
                        // the passwordless user ID with the thirdpartyemailpassword
                        // user ID, so that later on, we can fetch the phone number.
                        await UserMetadata.updateUserMetadata(
                            session!.getUserId(), // this is the userId of the first factor login
                            {
                                passwordlessUserId: resp.user.id,
                            }
                        );
                    }

                    return resp;
                },
            };
        },
    }
})

Session.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
                /* This function is called after signing in or signing up via the first factor */
                createNewSession: async function (input) {
                    // highlight-start
                    if (input.userContext.session !== undefined) {
                        /**
                        * This will be true for the second factor login.
                        * So instead of creating a new session, we return the already existing one.
                        */
                        return input.userContext.session;
                    }
                    // highlight-end
                    return originalImplementation.createNewSession({
                        ...input,
                        accessTokenPayload: {
                            ...input.accessTokenPayload,
                            is2faComplete: false
                        },
                    });
                },
            };
        },
    },
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">
TODO
</TabItem>
</BackendSDKTabs>

## 4) Validating the phone number

By default, the Passwordless API for sending an OTP (`createCodePOST`) sends the OTP to the input phone number, and if we don't modify that, the attack below is be possible:

- Alice (user) signs up using a weak password and their phone number.
- Mallory (attacker) successfully guesses Alice's password and queries the OTP sending API manually, to inject her phone number for the second factor auth.
- OTP is sent to Mallory's phone number and she can pass the second factor challenge.

To make it secure, we override the `createCodePOST` API and check that the input phone number is the same as the phone number associated with the user. If it's not the same, we throw an error, and if it is the same, we continue:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Passwordless.init({
    flowType: "USER_INPUT_CODE",
    contactMethod: "PHONE",
    override: {
        apis: (oI) => {
            return {
                ...oI,
                /*This API is called to send an OTP*/
                createCodePOST: async function (input) {
                    /**
                    * We want to make sure that the OTP being generated is for the
                    * same number that belongs to this user.
                    */

                    // A session should already exist since this should be called after the first
                    // factor is completed.
                    let session = await Session.getSession(input.options.req, input.options.res);

                    // We try and get the phone number associated with this user. It will be
                    // defined if this is a sign in attempt, in which case, we will check that
                    // it is equal to the input phone number
                    let userMetadata = await UserMetadata.getUserMetadata(session!.getUserId());
                    let phoneNumber: string | undefined = undefined;
                    if (userMetadata.metadata.passwordlessUserId !== undefined) {
                        // the flow will come here during a login attempt, since we
                        // associate the passwordless userId to the user on sign up
                        let passwordlessUserInfo = await Passwordless.getUserById({
                            userId: userMetadata.metadata.passwordlessUserId as string,
                            userContext: input.userContext,
                        });
                        phoneNumber = passwordlessUserInfo?.phoneNumber;
                    }

                    if (phoneNumber !== undefined) {
                        // this means we found a phone number associated to this user.
                        // we will check if the input phone number is the same as this one.
                        if (!("phoneNumber" in input) || input.phoneNumber !== phoneNumber) {
                            throw new Error("Input phone number is not the same as the one saved for this user");
                        }
                    }

                    return oI.createCodePOST!(input);
                },
                consumeCodePOST: async function (input) {
                    /*...mofications from previous step */
                    let resp = await oI.consumeCodePOST!(input);
                    /*...mofications from previous step */
                    return resp;
                },
            };
        },
    }
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">
TODO
</TabItem>
</BackendSDKTabs>

## 5) Storing the user's phone number in the session (optional)

When the session is first created (after the first factor is completed), we store the user's phone number in the session (if it exists), so that the frontend can call the `createCodePOST` API (to intiate the second factor challenge) without asking the user for their phone number again.

We do this by modifying the `createNewSession` function in the `Session.init` call:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Session.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
                /* This function is called after signing in or signing up via the first factor */
                createNewSession: async function (input) {
                    if (input.userContext.session !== undefined) {
                        /**
                        * This will be true for the second factor login.
                        * So instead of creating a new session, we return the already existing one.
                        */
                        return input.userContext.session;
                    }

                    // highlight-start
                    // we first get the passwordless userId associated with this user
                    // using the UserMetadata recipe
                    let userMetadata = await UserMetadata.getUserMetadata(input.userId);
                    let phoneNumber: string | undefined = undefined;
                    if (userMetadata.metadata.passwordlessUserId !== undefined) {
                        // We get the phone number associated with the passwordless userId.
                        let passwordlessUserInfo = await Passwordless.getUserById({
                            userId: userMetadata.metadata.passwordlessUserId as string,
                            userContext: input.userContext,
                        });
                        phoneNumber = passwordlessUserInfo?.phoneNumber;
                    }
                    // highlight-end

                    return originalImplementation.createNewSession({
                        ...input,
                        accessTokenPayload: {
                            ...input.accessTokenPayload,
                            is2faComplete: false,
                            // highlight-next-line
                            phoneNumber,
                        },
                    });
                },
            };
        },
    },
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">
TODO
</TabItem>
</BackendSDKTabs>

We can then further modify the customisation in step (4) to simply read from the session's payload making it more efficient:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Passwordless.init({
    flowType: "USER_INPUT_CODE",
    contactMethod: "PHONE",
    override: {
        apis: (oI) => {
            return {
                ...oI,
                /*This API is called to send an OTP*/
                createCodePOST: async function (input) {
                    /**
                    * We want to make sure that the OTP being generated is for the
                    * same number that belongs to this user.
                    */

                    // A session should already exist since this should be called after the first
                    // factor is completed.
                    let session = await Session.getSession(input.options.req, input.options.res);

                    // highlight-next-line
                    let phoneNumber: string = session!.getAccessTokenPayload().phoneNumber;

                    if (phoneNumber !== undefined) {
                        // this means we found a phone number associated to this user.
                        // we will check if the input phone number is the same as this one.
                        if (!("phoneNumber" in input) || input.phoneNumber !== phoneNumber) {
                            throw new Error("Input phone number is not the same as the one saved for this user");
                        }
                    }

                    return oI.createCodePOST!(input);
                },
                consumeCodePOST: async function (input) {
                    /*...mofications from previous step */
                    let resp = await oI.consumeCodePOST!(input);
                    /*...mofications from previous step */
                    return resp;
                },
            };
        },
    }
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">
TODO
</TabItem>
</BackendSDKTabs>