---
id: second-factor
title: "Setting up the second factor"
hide_title: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import TabItem from '@theme/TabItem';
import NodeJSFrameworkSubTabsServerless from "/src/components/tabs/NodeJSFrameworkSubTabsServerless"
import GoFrameworkSubTabs from "/src/components/tabs/GoFrameworkSubTabs"
import PythonFrameworkSubTabs from "/src/components/tabs/PythonFrameworkSubTabs"
import BackendSDKCasing from "/src/components/BackendSDKCasing"
import AppInfoForm from "/src/components/appInfoForm"
import CoreInjector from "/src/components/coreInjector"

# Setting up the 2nd factor

## 1) Initialisation

We will be using the [Passwordless recipe](https://supertokens.com/docs/passwordless/introduction) with SMS OTP as the second factor. You can follow the recipe's [backend quick setup guide](https://supertokens.com/docs/passwordless/quick-setup/backend) to configure a different method as well (for example with email magic links).

The `Passwordless.init` function should look something like this:

<AppInfoForm
    askForAppName
    askForAPIDomain
    askForWebsiteDomain
>

<CoreInjector>

<BackendSDKTabs>
<TabItem value="nodejs">

<NodeJSFrameworkSubTabsServerless>
<TabItem value="express">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "express",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/thirdpartyemailpassword/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({/*Override from previous step*/})
    ]
});
```
</TabItem>

<TabItem value="hapi">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "hapi",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/session/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({ /*Override from previous step*/ })
    ]
});
```
</TabItem>

<TabItem value="fastify">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "fastify",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/session/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({/*Override from previous step*/})
    ]
});
```
</TabItem>

<TabItem value="koa">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "koa",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/session/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({/*Override from previous step*/})
    ]
});
```
</TabItem>

<TabItem value="loopback">

```tsx
import supertokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import ThirdPartyEmailPassword from"supertokens-node/recipe/thirdpartyemailpassword";
import Passwordless from "supertokens-node/recipe/passwordless"

supertokens.init({
    framework: "loopback",
    supertokens: {
        ^{coreInjector_connection_uri_comment}
        connectionURI: ^{coreInjector_uri}
        ^{coreInjector_api_key_commented}apiKey: ^{coreInjector_api_key},
    },
    appInfo: {
        // learn more about this on https://supertokens.com/docs/session/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    recipeList: [
        // highlight-start
        Passwordless.init({
            flowType: "USER_INPUT_CODE",
            contactMethod: "PHONE"
        }),
        // highlight-end
        ThirdPartyEmailPassword.init({/*...*/}),
        Session.init({/*Override from previous step*/})
    ]
});
```
</TabItem>
<TabItem value="serverless">

:::important
Please refer the **Serverless Deployment** section in the Passwordless recipe guide
:::

</TabItem>
<TabItem value="nextjs">

:::important
Please refer the **NextJS** section in the Passwordless recipe guide
:::

</TabItem>
<TabItem value="nestjs">

:::important
Please refer the **NestJS** section in the Passwordless recipe guide
:::

</TabItem>
</NodeJSFrameworkSubTabsServerless>
</TabItem>
<TabItem value="go">

```go
import (
    "github.com/supertokens/supertokens-golang/recipe/passwordless"
	"github.com/supertokens/supertokens-golang/recipe/passwordless/plessmodels"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword/tpepmodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
    apiBasePath := "^{form_apiBasePath}"
    websiteBasePath := "^{form_websiteBasePath}"
	err := supertokens.Init(supertokens.TypeInput{
		Supertokens: &supertokens.ConnectionInfo{
            ^{coreInjector_connection_uri_comment}
            ConnectionURI: ^{coreInjector_uri}
            ^{coreInjector_api_key_commented}APIKey: ^{coreInjector_api_key},
		},
		AppInfo: supertokens.AppInfo{
            AppName: "^{form_appName}",
            APIDomain: "^{form_apiDomain}",
            WebsiteDomain: "^{form_websiteDomain}",
            APIBasePath: &apiBasePath,
            WebsiteBasePath: &websiteBasePath,
		},
		RecipeList: []supertokens.Recipe{
            // highlight-start
            passwordless.Init(plessmodels.TypeInput{
                FlowType: "USER_INPUT_CODE",
                ContactMethodPhone: plessmodels.ContactMethodPhoneConfig{
                    Enabled: true,
                },
            }),
            // highlight-end
			thirdpartyemailpassword.Init(&tpepmodels.TypeInput{/*...*/}),
			session.Init(&sessmodels.TypeInput{
				/*Override from previous step*/
			}),
		},
	})

	if err != nil {
		panic(err.Error())
	}
}
```
</TabItem>
<TabItem value="python">
<PythonFrameworkSubTabs>
<TabItem value="fastapi">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import thirdpartyemailpassword, session, passwordless
from supertokens_python.recipe.passwordless import ContactPhoneOnlyConfig

init(
    app_info=InputAppInfo(
        app_name="^{form_appName}",
        api_domain="^{form_apiDomain}",
        website_domain="^{form_websiteDomain}",
        api_base_path="^{form_apiBasePath}",
        website_base_path="^{form_websiteBasePath}"
    ),
    supertokens_config=SupertokensConfig(
        ^{coreInjector_connection_uri_comment_with_hash}
        connection_uri=^{coreInjector_uri}
        ^{coreInjector_api_key_commented_with_hash}api_key=^{coreInjector_api_key}
    ),
    framework='fastapi',
    recipe_list=[
	    session.init(), # contains the override from the previous step
        thirdpartyemailpassword.init(
           # ...
        ),
        # highlight-start
        passwordless.init(
            flow_type="USER_INPUT_CODE",
            contact_config=ContactPhoneOnlyConfig()
        )
        # highlight-end
    ],
    mode='asgi' # use wsgi if you are running using gunicorn
)
```

</TabItem>
<TabItem value="flask">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import thirdpartyemailpassword, session, passwordless
from supertokens_python.recipe.passwordless import ContactPhoneOnlyConfig

init(
    app_info=InputAppInfo(
        app_name="^{form_appName}",
        api_domain="^{form_apiDomain}",
        website_domain="^{form_websiteDomain}",
        api_base_path="^{form_apiBasePath}",
        website_base_path="^{form_websiteBasePath}"
    ),
    supertokens_config=SupertokensConfig(
        ^{coreInjector_connection_uri_comment_with_hash}
        connection_uri=^{coreInjector_uri}
        ^{coreInjector_api_key_commented_with_hash}api_key=^{coreInjector_api_key}
    ),
    framework='flask',
    recipe_list=[
	    session.init(), # contains the override from the previous step
        thirdpartyemailpassword.init(
           # ...
        ),
        # highlight-start
        passwordless.init(
            flow_type="USER_INPUT_CODE",
            contact_config=ContactPhoneOnlyConfig()
        )
        # highlight-end
    ]
)
```

</TabItem>
<TabItem value="django">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import thirdpartyemailpassword, session, passwordless
from supertokens_python.recipe.passwordless import ContactPhoneOnlyConfig

init(
    app_info=InputAppInfo(
        app_name="^{form_appName}",
        api_domain="^{form_apiDomain}",
        website_domain="^{form_websiteDomain}",
        api_base_path="^{form_apiBasePath}",
        website_base_path="^{form_websiteBasePath}"
    ),
    supertokens_config=SupertokensConfig(
        ^{coreInjector_connection_uri_comment_with_hash}
        connection_uri=^{coreInjector_uri}
        ^{coreInjector_api_key_commented_with_hash}api_key=^{coreInjector_api_key}
    ),
    framework='django',
    recipe_list=[
	    session.init(), # contains the override from the previous step
        thirdpartyemailpassword.init(
           # ...
        ),
        # highlight-start
        passwordless.init(
            flow_type="USER_INPUT_CODE",
            contact_config=ContactPhoneOnlyConfig()
        )
        # highlight-end
    ],
    mode='asgi' # use wsgi if you are running django server in sync mode
)
```

</TabItem>
</PythonFrameworkSubTabs>
</TabItem>
</BackendSDKTabs>
</CoreInjector>
</AppInfoForm>

The above will expose all the APIs to the frontend that can be used to create and verify the OTP.

## 2) Saving the user's phone number post second factor auth

During sign up, once the user has completed the second factor, we want to save their phone number against their profile. For this, we will use the `UserMetadata` recipe.

:::important
Make sure to add the User Metadata in the recipe list.
:::

The passwordless recipe will create a new `userId` for the user against which it will save the phone number. We can associate the passwordless `userId` with the `userId` of the first factor, and this way, we associate a phone number to the user:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Passwordless.init({
    flowType: "USER_INPUT_CODE",
    contactMethod: "PHONE",
    override: {
        apis: (oI) => {
            return {
                ...oI,
                // this API is called when the user enters the OTP
                consumeCodePOST: async function (input) {
                    // we should already have a session here since this is called
                    // after first factor login
                    let session = await Session.getSession(input.options.req, input.options.res);
                    
                    let resp = await oI.consumeCodePOST!(input);

                    if (resp.status === "OK") {
                        // OTP verification was successful. We can now associate 
                        // the passwordless user ID with the thirdpartyemailpassword
                        // user ID, so that later on, we can fetch the phone number.
                        await UserMetadata.updateUserMetadata(
                            session!.getUserId(), // this is the userId of the first factor login
                            {
                                passwordlessUserId: resp.user.id,
                            }
                        );
                    }

                    return resp;
                },
            };
        },
    }
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe.passwordless.interfaces import APIInterface, APIOptions, ConsumeCodePostOkResult
from typing import Union, Dict, Any
from supertokens_python.recipe.session.asyncio import get_session
from supertokens_python.recipe.usermetadata.asyncio import update_user_metadata


def override_passwordless_apis(original_implementation: APIInterface):
    original_consume_code_post = original_implementation.consume_code_post

    async def consume_code_post(
        pre_auth_session_id: str,
        user_input_code: Union[str, None],
        device_id: Union[str, None],
        link_code: Union[str, None],
        api_options: APIOptions,
        user_context: Dict[str, Any],
    ):
        # this API is called when the user enters the OTP
        # we should already have a session here since this is called
        # after first factor login
        _session = await get_session(api_options.request)
        assert _session is not None

        res = await original_consume_code_post(
            pre_auth_session_id,
            user_input_code,
            device_id,
            link_code,
            api_options,
            user_context,
        )

        if isinstance(res, ConsumeCodePostOkResult):
            await update_user_metadata(
                _session.get_user_id(), {"passwordlessUserId": res.user.user_id}
            )

        return res

    original_implementation.consume_code_post = consume_code_post
    return original_implementation

```

</TabItem>
</BackendSDKTabs>

## 3) Updating the session post second factor auth

We also want to change the session's payload to indicate that the user has completed the second factor. In our example, we do this by setting the `is2faComplete` property to `true` in the session's access token payload.

We also have to be careful about not creating a new session after the second factor auth is completed. By default, the passwordless recipe will create a new session on successul verification, overwriting the older one. We can do this by using the `userContext` feature:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Passwordless.init({
    flowType: "USER_INPUT_CODE",
    contactMethod: "PHONE",
    override: {
        apis: (oI) => {
            return {
                ...oI,
                // this API is called when the user enters the OTP
                consumeCodePOST: async function (input) {
                    // we should already have a session here since this is called
                    // after first factor login
                    let session = await Session.getSession(input.options.req, input.options.res);
                    
                    // highlight-start
                    // we add the existing session to the user context so that the createNewSession
                    // function doesn't create a new session
                    input.userContext.session = session;
                    // highlight-end

                    let resp = await oI.consumeCodePOST!(input);

                    if (resp.status === "OK") {
                        // highlight-start
                        // OTP verification was successful. We can now mark the
                        // session's payload as is2faComplete: true so that
                        // the user has access to API routes and the frontend UI
                        await resp.session.updateAccessTokenPayload({
                            ...resp.session.getAccessTokenPayload(),
                            is2faComplete: true,
                        });
                        // highlight-end

                        // We can now associate 
                        // the passwordless user ID with the thirdpartyemailpassword
                        // user ID, so that later on, we can fetch the phone number.
                        await UserMetadata.updateUserMetadata(
                            session!.getUserId(), // this is the userId of the first factor login
                            {
                                passwordlessUserId: resp.user.id,
                            }
                        );
                    }

                    return resp;
                },
            };
        },
    }
})

Session.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
                /* This function is called after signing in or signing up via the first factor */
                createNewSession: async function (input) {
                    // highlight-start
                    if (input.userContext.session !== undefined) {
                        /**
                        * This will be true for the second factor login.
                        * So instead of creating a new session, we return the already existing one.
                        */
                        return input.userContext.session;
                    }
                    // highlight-end
                    return originalImplementation.createNewSession({
                        ...input,
                        accessTokenPayload: {
                            ...input.accessTokenPayload,
                            is2faComplete: false
                        },
                    });
                },
            };
        },
    },
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe.passwordless.interfaces import APIInterface, APIOptions, ConsumeCodePostOkResult
from typing import Union, Dict, Any
from supertokens_python.recipe.session.asyncio import get_session
from supertokens_python.recipe.usermetadata.asyncio import update_user_metadata
from supertokens_python.recipe.session.interfaces import SessionContainer, RecipeInterface


def override_passwordless_apis(original_implementation: APIInterface):
    original_consume_code_post = original_implementation.consume_code_post

    async def consume_code_post(
        pre_auth_session_id: str,
        user_input_code: Union[str, None],
        device_id: Union[str, None],
        link_code: Union[str, None],
        api_options: APIOptions,
        user_context: Dict[str, Any],
    ):
        # this API is called when the user enters the OTP
        # we should already have a session here since this is called
        # after first factor login
        _session = await get_session(api_options.request)
        assert _session is not None

        # we should add the existing session to the user_context
        # so that the create_new_session function doesn't
        # create a new session
        # highlight-next-line
        user_context["session"] = _session

        res = await original_consume_code_post(
            pre_auth_session_id,
            user_input_code,
            device_id,
            link_code,
            api_options,
            user_context,
        )

        if isinstance(res, ConsumeCodePostOkResult):
            # highlight-start
            # OTP verification was successful. We can now mark the
            # session's payload as {"is2faComplete": True} so that
            # the user has access to API routes and the frontend UI
            await _session.update_access_token_payload(
                {**_session.get_access_token_payload(), "is2faComplete": True}
            )
            # highlight-end

            await update_user_metadata(
                _session.get_user_id(), {"passwordlessUserId": res.user.user_id}
            )

        return res

    original_implementation.consume_code_post = consume_code_post
    return original_implementation

def override_session_functions(original_implementation: RecipeInterface):
    original_create_new_session = original_implementation.create_new_session

    async def create_new_session(
        request: Any,
        user_id: str,
        access_token_payload: Union[None, Dict[str, Any]],
        session_data: Union[None, Dict[str, Any]],
        user_context: Dict[str, Any],
    ):
        # highlight-start
        _session = user_context.get("session")
        if _session and isinstance(_session, SessionContainer):
            # This condition will be true for the second factor login.
            # So instead of creating a new session, we return the already existing one.
            return _session
        # highlight-end

        if access_token_payload is None:
            access_token_payload = {}

        # Insert "is2faComplete" in access token payload
        access_token_payload = {**access_token_payload, "is2faComplete": False}
        return await original_create_new_session(
            request, user_id, access_token_payload, session_data, user_context
        )

    original_implementation.create_new_session = create_new_session
    return original_implementation

```

</TabItem>
</BackendSDKTabs>

## 4) Validating the phone number

By default, the Passwordless API for sending an OTP (`createCodePOST`) sends the OTP to the input phone number, and if we don't modify that, the attack below is be possible:

- Alice (user) signs up using a weak password and their phone number.
- Mallory (attacker) successfully guesses Alice's password and queries the OTP sending API manually, to inject her phone number for the second factor auth.
- OTP is sent to Mallory's phone number and she can pass the second factor challenge.

To make it secure, we override the `createCodePOST` API and check that the input phone number is the same as the phone number associated with the user. If it's not the same, we throw an error, and if it is the same, we continue:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Passwordless.init({
    flowType: "USER_INPUT_CODE",
    contactMethod: "PHONE",
    override: {
        apis: (oI) => {
            return {
                ...oI,
                /*This API is called to send an OTP*/
                createCodePOST: async function (input) {
                    /**
                    * We want to make sure that the OTP being generated is for the
                    * same number that belongs to this user.
                    */

                    // A session should already exist since this should be called after the first
                    // factor is completed.
                    let session = await Session.getSession(input.options.req, input.options.res);

                    // We try and get the phone number associated with this user. It will be
                    // defined if this is a sign in attempt, in which case, we will check that
                    // it is equal to the input phone number
                    let userMetadata = await UserMetadata.getUserMetadata(session!.getUserId());
                    let phoneNumber: string | undefined = undefined;
                    if (userMetadata.metadata.passwordlessUserId !== undefined) {
                        // the flow will come here during a login attempt, since we
                        // associate the passwordless userId to the user on sign up
                        let passwordlessUserInfo = await Passwordless.getUserById({
                            userId: userMetadata.metadata.passwordlessUserId as string,
                            userContext: input.userContext,
                        });
                        phoneNumber = passwordlessUserInfo?.phoneNumber;
                    }

                    if (phoneNumber !== undefined) {
                        // this means we found a phone number associated to this user.
                        // we will check if the input phone number is the same as this one.
                        if (!("phoneNumber" in input) || input.phoneNumber !== phoneNumber) {
                            throw new Error("Input phone number is not the same as the one saved for this user");
                        }
                    }

                    return oI.createCodePOST!(input);
                },
                consumeCodePOST: async function (input) {
                    /*...mofications from previous step */
                    let resp = await oI.consumeCodePOST!(input);
                    /*...mofications from previous step */
                    return resp;
                },
            };
        },
    }
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe.passwordless.interfaces import APIInterface, APIOptions
from typing import Union, Dict, Any, Optional
from supertokens_python.recipe.session.asyncio import get_session
from supertokens_python.recipe.usermetadata.asyncio import get_user_metadata
from supertokens_python.recipe.passwordless.asyncio import get_user_by_id


def override_passwordless_apis(original_implementation: APIInterface):
    original_consume_code_post = original_implementation.consume_code_post
    original_create_code_post = original_implementation.create_code_post

    async def create_code_post(
        email: Union[str, None],
        phone_number: Union[str, None],
        api_options: APIOptions,
        user_context: Dict[str, Any],
    ):
        # This API is called to send an OTP
        # We want to make sure that the OTP being generated is for the
        # same number that belongs to this user.

        # A session should already exist since this should be called after the first
        # factor is completed
        _session = await get_session(api_options.request)
        assert _session is not None

        # We try to get the phone number associated with this user. It will be
        # defined if this is a sign in attempt, in which case, we will check that
        # it is equal to the input phone number
        user_metadata = await get_user_metadata(_session.get_user_id())
        user_metadata_phone_number: Optional[str] = None
        if user_metadata.metadata.get("passwordlessUserId"):
            # the flow will come here during a login attempt, since we
            # associate the passwordless userId to the user on sign up
            passwordless_user_info = await get_user_by_id(
                user_metadata.metadata["passwordlessUserId"], user_context
            )
            if passwordless_user_info is not None:
                user_metadata_phone_number = passwordless_user_info.phone_number

        if user_metadata_phone_number is not None:
            # this means we found a phone number associated to this user
            # we will check if the input phone number is the same as this one.
            if phone_number is not None and phone_number != user_metadata_phone_number:
                raise Exception(
                    "Input phone number is not the same as the one saved for this user"
                )

        return await original_create_code_post(
            email, phone_number, api_options, user_context
        )

    async def consume_code_post(
        pre_auth_session_id: str,
        user_input_code: Union[str, None],
        device_id: Union[str, None],
        link_code: Union[str, None],
        api_options: APIOptions,
        user_context: Dict[str, Any],
    ):
        # MODIFICATIONS FROM PREVIOUS STEP
        res = await original_consume_code_post(
            pre_auth_session_id,
            user_input_code,
            device_id,
            link_code,
            api_options,
            user_context,
        )
        # MODIFICATIONS FROM PREVIOUS STEP
        return res

    original_implementation.create_code_post = create_code_post
    original_implementation.consume_code_post = consume_code_post
    return original_implementation

```

</TabItem>
</BackendSDKTabs>

## 5) Storing the user's phone number in the session

When the session is first created (after the first factor is completed), we store the user's phone number in the session (if it exists), so that the frontend can call the `createCodePOST` API (to intiate the second factor challenge) without asking the user for their phone number again.

We do this by modifying the `createNewSession` function in the `Session.init` call:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Session.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
                /* This function is called after signing in or signing up via the first factor */
                createNewSession: async function (input) {
                    if (input.userContext.session !== undefined) {
                        /**
                        * This will be true for the second factor login.
                        * So instead of creating a new session, we return the already existing one.
                        */
                        return input.userContext.session;
                    }

                    // highlight-start
                    // we first get the passwordless userId associated with this user
                    // using the UserMetadata recipe
                    let userMetadata = await UserMetadata.getUserMetadata(input.userId);
                    let phoneNumber: string | undefined = undefined;
                    if (userMetadata.metadata.passwordlessUserId !== undefined) {
                        // We get the phone number associated with the passwordless userId.
                        let passwordlessUserInfo = await Passwordless.getUserById({
                            userId: userMetadata.metadata.passwordlessUserId as string,
                            userContext: input.userContext,
                        });
                        phoneNumber = passwordlessUserInfo?.phoneNumber;
                    }
                    // highlight-end

                    return originalImplementation.createNewSession({
                        ...input,
                        accessTokenPayload: {
                            ...input.accessTokenPayload,
                            is2faComplete: false,
                            // highlight-next-line
                            phoneNumber,
                        },
                    });
                },
            };
        },
    },
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">

```python
from typing import Union, Dict, Any, Optional
from supertokens_python.recipe.usermetadata.asyncio import get_user_metadata
from supertokens_python.recipe.passwordless.asyncio import get_user_by_id
from supertokens_python.recipe.session.interfaces import SessionContainer, RecipeInterface


def override_session_functions(original_implementation: RecipeInterface):
    original_create_new_session = original_implementation.create_new_session

    async def create_new_session(
        request: Any,
        user_id: str,
        access_token_payload: Union[None, Dict[str, Any]],
        session_data: Union[None, Dict[str, Any]],
        user_context: Dict[str, Any],
    ):
        _session = user_context.get("session")
        if _session and isinstance(_session, SessionContainer):
            # This condition will be true for the second factor login.
            # So instead of creating a new session, we return the already existing one.
            return _session

        if access_token_payload is None:
            access_token_payload = {}

        # highlight-start
        # we first get the passwordless user id associated with this user
        # using the UserMetadata recipe
        user_metadata = await get_user_metadata(user_id)
        phone_number: Optional[str] = None
        if user_metadata.metadata.get("passwordlessUserId") is not None:
            passwordless_user_info = await get_user_by_id(
                user_metadata.metadata["passwordlessUserId"], user_context
            )
            if passwordless_user_info is not None:
                phone_number = passwordless_user_info.phone_number
        # highlight-end

        # Insert "is2faComplete" and "phoneNumber" in the access token payload
        access_token_payload = {
            **access_token_payload,
            "is2faComplete": False,
            # highlight-next-line
            "phoneNumber": phone_number,
        }
        return await original_create_new_session(
            request, user_id, access_token_payload, session_data, user_context
        )

    original_implementation.create_new_session = create_new_session
    return original_implementation

```

</TabItem>
</BackendSDKTabs>

We can then further modify the customisation in step (4) to simply read from the session's payload making it more efficient:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import Session from "supertokens-node/recipe/session";
import UserMetadata from "supertokens-node/recipe/usermetadata";
import Passwordless from "supertokens-node/recipe/passwordless";

Passwordless.init({
    flowType: "USER_INPUT_CODE",
    contactMethod: "PHONE",
    override: {
        apis: (oI) => {
            return {
                ...oI,
                /*This API is called to send an OTP*/
                createCodePOST: async function (input) {
                    /**
                    * We want to make sure that the OTP being generated is for the
                    * same number that belongs to this user.
                    */

                    // A session should already exist since this should be called after the first
                    // factor is completed.
                    let session = await Session.getSession(input.options.req, input.options.res);

                    // highlight-next-line
                    let phoneNumber: string = session!.getAccessTokenPayload().phoneNumber;

                    if (phoneNumber !== undefined) {
                        // this means we found a phone number associated to this user.
                        // we will check if the input phone number is the same as this one.
                        if (!("phoneNumber" in input) || input.phoneNumber !== phoneNumber) {
                            throw new Error("Input phone number is not the same as the one saved for this user");
                        }
                    }

                    return oI.createCodePOST!(input);
                },
                consumeCodePOST: async function (input) {
                    /*...mofications from previous step */
                    let resp = await oI.consumeCodePOST!(input);
                    /*...mofications from previous step */
                    return resp;
                },
            };
        },
    }
})
```

</TabItem>
<TabItem value="go">
TODO
</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe.passwordless.interfaces import APIInterface, APIOptions
from typing import Union, Dict, Any
from supertokens_python.recipe.session.asyncio import get_session


def override_passwordless_apis(original_implementation: APIInterface):
    original_create_code_post = original_implementation.create_code_post

    async def create_code_post(
        email: Union[str, None],
        phone_number: Union[str, None],
        api_options: APIOptions,
        user_context: Dict[str, Any],
    ):
        # This API is called to send an OTP
        # We want to make sure that the OTP being generated is for the
        # same number that belongs to this user.

        # A session should already exist since this should be called after the first
        # factor is completed
        _session = await get_session(api_options.request)
        assert _session is not None

        # highlight-next-line
        payload_phone_number = _session.get_access_token_payload().get("phone_number")

        if payload_phone_number is not None:
            # this means we found a phone number associated to this user
            # we will check if the input phone number is the same as this one.
            if phone_number is not None and phone_number != payload_phone_number:
                raise Exception(
                    "Input phone number is not the same as the one saved for this user"
                )

        return await original_create_code_post(
            email, phone_number, api_options, user_context
        )
    
    original_implementation.create_code_post = create_code_post

```

</TabItem>
</BackendSDKTabs>
