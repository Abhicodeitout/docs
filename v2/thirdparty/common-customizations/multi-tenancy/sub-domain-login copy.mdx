---
id: sub-domain-login
title: "Option 2: Tenants use their sub domain to login"
hide_title: true
show_ui_switcher: true
---

import AppInfoForm from "/src/components/appInfoForm"
import MultiTenancyPaidBanner from '../../../community/reusableMD/multitenancy/MultiTenancyPaidBanner.mdx'
import {PreBuiltOrCustomUISwitcher, PreBuiltUIContent, CustomUIContent} from "/src/components/preBuiltOrCustomUISwitcher"
import FrontendPreBuiltUITabs from "/src/components/tabs/FrontendPreBuiltUITabs"
import FrontendCustomUITabs from "/src/components/tabs/FrontendCustomUITabs"
import NpmOrScriptTabs from "/src/components/tabs/NpmOrScriptTabs"
import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";

<MultiTenancyPaidBanner />

# Option 2: Tenants use their sub domain to login

In this UX flow, all tenants login using their assigned sub domain (`customer1.example.com`, `customer2.example.com` and so on). The login method that's shown on the login page on each sub domain depends on that tenant's `tenantId` configuration. 

Throughout this page, we will assume that the tenant ID for a tenant is equal to their sub domain - so if the sub domain assigned to a tenant is `customer.example.com`, then their tenantId is `customer1`.

<!-- COPY SECTION -->
<!-- ./thirdparty/common-customizations/multi-tenancy/common-domain-login.mdx  -->
<!-- 1 -->

## Step 1: Creating a new tenant

Whenever you want to onboard a new customer, you should [create and configure a tenantId for them in the SuperTokens core](./new-tenant-config). If you want to create a self serve flow, in which customers can automatically sign up and create and configure their SSO provider in SuperTokens, checkout [this page](./TODO).

<!-- END COPY SECTION -->

## Step 2: Load login methods dynamically on the frontend based on the tenantId

TODO

## Step 3: Tell SuperTokens about tenant's sub domains

TODO

<!-- COPY SECTION -->
<!-- ./thirdparty/common-customizations/multi-tenancy/common-domain-login.mdx  -->
<!-- 2 -->

<BackendSDKTabs>

<TabItem value="nodejs">

```tsx
TODO
```

</TabItem>
<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/multitenancy"
	"github.com/supertokens/supertokens-golang/recipe/multitenancy/multitenancymodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	supertokens.Init(supertokens.TypeInput{
		RecipeList: []supertokens.Recipe{
            // highlight-start
			multitenancy.Init(&multitenancymodels.TypeInput{
				GetAllowedDomainsForTenantId: func(tenantId string) ([]string, error) {
					// query your db to get the allowed domain for the input tenantId
					// or you can make the tenantId equal to the sub domain itself
					return []string{tenantId + ".myapp.com", "myapp.com"}, nil
				},
			}),
            // highlight-end
		},
	})
}
```

</TabItem>
<TabItem value="python">

```python
TODO
```

</TabItem>

</BackendSDKTabs>

The config above will tell SuperTokens to add the list of domains returned by you into the user's session claims once they login. This claim can then be read on the frontend and backend to restrict user's access to the right domain(s).

<!-- END COPY SECTION -->

## Step 4: Sharing sessions across sub domains

You may want to allow the user's session to be shearable across sub domains. This would lead to a better UX in which even if they visit the main domain (logged in via `a.example.com`, and visit `example.com`), the frontend app there can detect if the user has a session or not.

This can be achieved [by setting the `sessionScope` value in the Session recipe](../sessions/share-sessions-across-sub-domains).

If the sub domain and the main website domain have different backends (on different sub domains), then you can also enable [sharing of sessions across API domains](../sessions/multiple-api-endpoints).

:::note
This is not a security issue because we will anyway be restricting access to users based on their domain allow list as shown below.
:::

## Step 5: Limiting the user's access to their sub domain.

<!-- COPY SECTION -->
<!-- ./thirdparty/common-customizations/multi-tenancy/common-domain-login.mdx  -->
<!-- 3 -->

We will be using [session claim validators](../sessions/claims/claim-validators) on the frontend and backend to restrict sub domain access.

### Restrict API access

Let's take an example here. We have a tenantId: `tId1` which has access to `example.com`, `tId1.example.com` (where their UI is shown), and to `api.tId1.example.com` (API layer that is allowed to be queried only by `tId1.examlpe.com`). 

First, make sure that all these domains are returned from the `GetAllowedDomainsForTenantId`:

<BackendSDKTabs>

<TabItem value="nodejs">

```tsx
TODO
```

</TabItem>
<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/multitenancy"
	"github.com/supertokens/supertokens-golang/recipe/multitenancy/multitenancymodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	supertokens.Init(supertokens.TypeInput{
		RecipeList: []supertokens.Recipe{
            // highlight-start
			multitenancy.Init(&multitenancymodels.TypeInput{
				GetAllowedDomainsForTenantId: func(tenantId string) ([]string, error) {
					return []string{tenantId + ".example.com", "example.com", "api." + tenantId + ".example.com"}, nil
				},
			}),
            // highlight-end
		},
	})
}
```

</TabItem>
<TabItem value="python">

```python
TODO
```

</TabItem>

</BackendSDKTabs>

This will add all the returned domains to that tenant's session. Then, we can add the following global claim validator on the backend to restrict it so that only tenants with `api.tId1.example.com` allowed domain can query that backend

<BackendSDKTabs>

<TabItem value="nodejs">

```tsx
TODO
```

</TabItem>
<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/claims"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	supertokens.Init(supertokens.TypeInput{
		RecipeList: []supertokens.Recipe{
			// other recipe inits...
			session.Init(&sessmodels.TypeInput{
				Override: &sessmodels.OverrideStruct{
					Functions: func(originalImplementation sessmodels.RecipeInterface) sessmodels.RecipeInterface {

						(*originalImplementation.GetGlobalClaimValidators) = func(userId string, claimValidatorsAddedByOtherRecipes []claims.SessionClaimValidator, userContext supertokens.UserContext) ([]claims.SessionClaimValidator, error) {
							return append(claimValidatorsAddedByOtherRecipes,
                            // highlight-next-line
                                multitenancyclaims.Validators.CheckAccessToDomain("api.tId1.example.com"))
						}

						return originalImplementation
					},
				},
			}),
		},
	})
}
```

</TabItem>
<TabItem value="python">

```python
TODO
```

</TabItem>

</BackendSDKTabs>

- This will make sure that whenever you call the `verifySession` or `getSession` functions, SuperTokens will check that the tenant has access to `api.tId1.example.com` (which should be the current API layer's code).
- In case you do not want to apply this check to all APIs, you can add this claim validator on a [per API level as well](../sessions/claims/claim-validators#adding-a-validator-check-to-a-specific-route).

### Restrict frontend access

On the frontend, we want to check if the tenant has access to the current sub domain. If not, we want to redirect them to the right sub domain. This can be done by using the `hasAccessToCurrentDomain` session validator from the multi tenancy recipe:

<PreBuiltOrCustomUISwitcher>

<PreBuiltUIContent>

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

```tsx
import React from "react";
import { SessionAuth, useSessionContext } from 'supertokens-auth-react/recipe/session';
import { MultitenancyClaim } from 'supertokens-auth-react/recipe/multitenancy';

const ProtectedRoute = (props: React.PropsWithChildren<any>) => {
    return (
        <SessionAuth
            overrideGlobalClaimValidators={(globalValidators) =>
                [...globalValidators,
                    MultitenancyClaim.validators.hasAccessToCurrentDomain()
                ]
            }
        >
            <InvalidClaimHandler>
                {props.children}
            </InvalidClaimHandler>
        </SessionAuth>
    );
}

function InvalidClaimHandler(props: React.PropsWithChildren<any>) {
    let sessionContext = useSessionContext();
    if (sessionContext.loading) {
        return null;
    }

    if (sessionContext.invalidClaims.some(i => i.validatorId === MultitenancyClaim.id)) {
        return <div>You cannot access this page.</div>
    }

    return <div>{props.children}</div>;
}
```
Above we are creating a generic component called `ProtectedRoute` which enforces that its child components can only be rendered if the user is on the right sub domain based on the Multi tenancy claim.

</TabItem>

<TabItem value="angular">

```tsx
import Session from "supertokens-web-js/recipe/session";
import { MultitenancyClaim } from "supertokens-web-js/recipe/multitenancy";

async function shouldLoadRoute(): Promise<boolean> {
    if (await Session.doesSessionExist()) {

        // highlight-start
        let validationErrors = await Session.validateClaims({
            overrideGlobalClaimValidators: (globalValidators) =>
                [...globalValidators,
                    MultitenancyClaim.validators.hasAccessToCurrentDomain(),
                ]
        });
        // highlight-end

        if (validationErrors.length === 0) {
            // user is an admin
            return true;
        }

        for (const err of validationErrors) {
            if (err.validatorId === MultitenancyClaim.id) {
                // multi tenancy domain check claim check failed
            } else {
                // some other claim check failed (from the global validators list)
            }
        }
    }

    return false
}
```

- We call the `validateClaims` function with the `MultitenancyClaim` validator which makes sure that the user is on the right sub domain.
- The `globalValidators` represents other validators that apply to all calls to the `validateClaims` function. This may include a validator that enforces that the user's email is verified (if enabled by you).

</TabItem>

</FrontendPreBuiltUITabs>

</PreBuiltUIContent>

<CustomUIContent>

<NpmOrScriptTabs>
<TabItem value="npm">

```tsx
import Session from "supertokens-web-js/recipe/session";
import { MultitenancyClaim } from "supertokens-web-js/recipe/multitenancy";

async function shouldLoadRoute(): Promise<boolean> {
    if (await Session.doesSessionExist()) {

        // highlight-start
        let validationErrors = await Session.validateClaims({
            overrideGlobalClaimValidators: (globalValidators) =>
                [...globalValidators,
                    MultitenancyClaim.validators.hasAccessToCurrentDomain(),
                ]
        });
        // highlight-end

        if (validationErrors.length === 0) {
            // user is an admin
            return true;
        }

        for (const err of validationErrors) {
            if (err.validatorId === MultitenancyClaim.id) {
                // multi tenancy domain check claim check failed
            } else {
                // some other claim check failed (from the global validators list)
            }
        }
    }

    return false
}
```


</TabItem>
<TabItem value="script">

```tsx
import supertokensSession from "supertokens-web-js-script/recipe/session";
import supertokensMultitenancy from "supertokens-web-js-script/recipe/multitenancy";

async function shouldLoadRoute(): Promise<boolean> {
    if (await supertokensSession.doesSessionExist()) {

        // highlight-start
        let validationErrors = await supertokensSession.validateClaims({
            overrideGlobalClaimValidators: (globalValidators) =>
                [...globalValidators,
                    supertokensMultitenancy.MultitenancyClaim.validators.hasAccessToCurrentDomain(),
                ]
        });
        // highlight-end

        if (validationErrors.length === 0) {
            // user is an admin
            return true;
        }

        for (const err of validationErrors) {
            if (err.validatorId === supertokensMultitenancy.MultitenancyClaim.id) {
                // multi tenancy domain check claim check failed
            } else {
                // some other claim check failed (from the global validators list)
            }
        }
    }

    return false
}
```

</TabItem>
</NpmOrScriptTabs>

- We call the `validateClaims` function with the `MultitenancyClaim` validator which makes sure that the user is on the right sub domain.
- The `globalValidators` represents other validators that apply to all calls to the `validateClaims` function. This may include a validator that enforces that the user's email is verified (if enabled by you).

</CustomUIContent>

</PreBuiltOrCustomUISwitcher>

<!-- END COPY SECTION -->