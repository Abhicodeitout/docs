---
id: multitenant-login
title: "Multitenant login"
hide_title: true
---

import AppInfoForm from "/src/components/appInfoForm"
import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import GoFrameworkSubTabs from "/src/components/tabs/GoFrameworkSubTabs";
import TabItem from '@theme/TabItem';

:::important
TODO BANNER This is a paid feature

If you wish to use this feature for free, follow this implementation guide TODO link
:::

# Multitenant login

## What is Multitenancy?

Multitenancy is a software architecture where multiple clients share the same set of computing resources. Each client in this context is known as a tenant. For example, applications like Slack or Github offer services to various enterprises, which inturn host their own set of users and data. Although the underlying application is same, there is a logical separation of users and data between the tenants.

SuperTokens supports multitenancy for the thirdparty recipe out of the box. Follow this guide to learn how to set it up.

## Multitenant login flow

TODO diagram

## Step 1: Add tenants and thirdparty providers to the SuperTokens core

### Create tenants

Use the endpoint below to create a tenant.

The `tenantId` is a unique identifier for each tenant. The `emailpasswordEnabled`, `thirdpartyEnabled` and `passwordlessEnabled` flags indicate whether the tenant has enabled the corresponding recipe.

```bash
curl --location --request PUT 'http://localhost:3567/recipe/multitenancy/tenant' \
--header 'Content-Type: application/json' \
--data-raw '{
    "tenantId": "...",
    "emailpasswordEnabled": true,
    "thirdpartyEnabled": true,
    "passwordlessEnabled": true
}'
```

### Add ThirdParty Providers to the core for the tenant created above

Once the tenants are created, add the thirdparty providers for each of the tenant using the endpoint below.

```bash
curl --location --request PUT 'http://localhost:3567/recipe/multitenancy/config/thirdparty' \
--header 'Content-Type: application/json' \
--data-raw '{
  "config": {
    "tenantId": "...",
    "thirdPartyId": "okta",
    "name": "Okta",
    "clients": [
      {
        "clientId": "string",
        "clientSecret": "string",
        "additionalConfig": {
          "oktaDomain": "..."
        }
      }
    ]
  }
}'
```

Repeat the above steps for all the tenants and their corresponding ThirdParty providers.

:::note
It is not necessary that every tenant has a same set of Third party providers. Each tenant can have completely different set of thirdparty providers and the SDK dynamically picks up the configuration from the core.
:::

## Step 2: Frontent setup

Modify the `SuperTokens.init` to do the following:
1. Set the `usesDynamicLoginMethods` to true and remove the providers list
2. Initialize the `Multitenancy` recipe and provide `getTenantId` config function

<AppInfoForm
    askForAppName
    askForAPIDomain
    askForWebsiteDomain
>

```tsx

import React from 'react';

import SuperTokens, { SuperTokensWrapper } from "supertokens-auth-react";
import ThirdParty from "supertokens-auth-react/recipe/thirdparty";
import Session from "supertokens-auth-react/recipe/session";
import Multitenancy from "supertokens-auth-react/recipe/multitenancy";

SuperTokens.init({
    appInfo: {
        // learn more about this on https://supertokens.com/docs/thirdpartyemailpassword/appinfo
        appName: "^{form_appName}",
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        websiteBasePath: "^{form_websiteBasePath}"
    },
    // highlight-start
    usesDynamicLoginMethods: true,
    // highlight-end
    recipeList: [
        // highlight-start
        ThirdParty.init(),
        // highlight-end
        Session.init(),
        // highlight-start
        Multitenancy.init({
          getTenantId: async () => {
            // Logic to determine the tenant id
            return "..."
          }
        })
        // highlight-end
    ]
});
```

The logic to determine the `tenantId` can be based on the intended setup. For example, you could provide a form input to accept the `tenantId` from the user. Or you could use the subdomain to determine the `tenantId`.

Refer one of these for further information (TODO link to the pages)
- Single Login Domain - asking users for tenantId
- Subdomain login

</AppInfoForm>

## Step 3: Backend setup

Remove the `providers` list from the `thirdparty` config. The backend SDK will automatically pick up the configuration stored in the core.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
TODO
```
</TabItem>
<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/thirdparty"
	"github.com/supertokens/supertokens-golang/recipe/thirdparty/tpmodels"
)

func main() {
	// Inside supertokens.Init
  // highlight-start
	thirdparty.Init(nil)
		// highlight-end
}
```
</TabItem>
<TabItem value="python">

```python
TODO
```

</TabItem>
</BackendSDKTabs>

If you are using different domains or sub-domains for each tenant on the frontend, the corsMiddleware needs to updated to allow requests from them.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
TODO
```
</TabItem>
<TabItem value="go">

<GoFrameworkSubTabs>

<TabItem value="http">

```go
func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(response http.ResponseWriter, r *http.Request) {
		// highlight-start
		origin := r.Header.Get("Origin")
		if !validateOrigin(origin) {
			response.WriteHeader(422)
			response.Write([]byte("Invalid tenant"))
			return
		}
		response.Header().Set("Access-Control-Allow-Origin", origin)
		// highlight-end
		response.Header().Set("Access-Control-Allow-Credentials", "true")
		if r.Method == "OPTIONS" {
			// we add content-type + other headers used by SuperTokens
			response.Header().Set("Access-Control-Allow-Headers",
				strings.Join(append([]string{"Content-Type"},
					supertokens.GetAllCORSHeaders()...), ","))
			response.Header().Set("Access-Control-Allow-Methods", "*")
			response.Write([]byte(""))
		} else {
			next.ServeHTTP(response, r)
		}
	})
}

// highlight-start
func validateOrigin(origin string) bool {
	// logic to validate origin
	return true
}
// highlight-end
```

</TabItem>

<TabItem value="chi">

```go
TODO
```

</TabItem>

<TabItem value="gin">

```go
TODO
```

</TabItem>

<TabItem value="mux">

```go
TODO
```

</TabItem>

</GoFrameworkSubTabs>

</TabItem>
<TabItem value="python">

```python
TODO
```

</TabItem>
</BackendSDKTabs>

## See also

TODO: links

- Single Login Domain - asking users for tenantId
- Single Login Domain - redirection post login
- Subdomain login
- Getting tenant id of logged in user
- Allowing end users to add their own SSO provider
- SAML login
