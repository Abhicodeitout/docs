---
id: jwt-creation
title: Creating a JWT
hide_title: true
---

import WithWithoutSDK from "/src/components/tabs/WithWithoutSDK";
import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import TabItem from '@theme/TabItem';
import PythonSyncAsyncSubTabs from "/src/components/tabs/PythonSyncAsyncSubTabs"

# Creating a JWT

## When to create a JWT?
The first step is to create a JWT from the microservice that will be sending the request (let's call this microservice `M1`). Depending on the context, this JWT can be created at different times:
- When handling a request from the frontend: A new JWT needs to be created on each request, containing the user ID of the user who sent the request from the frontend.
- On process start: A new JWT is created when `M1` starts. The contents of this JWT are not tied to a specific end user, and this JWT remains static until `M1` restarts.

## What to add in the JWT?
In either case, the JWT needs to contain some information identifying `M1` so that the target microservice (let's call this `M2`) can verify the source of the request. We have two choices here:
- Add `M1` specific informatoin in the JWT: For example, we could add:
    ```json
    {..., "microservice_id": "M1", ...}
    ```

    `M2` could have a list of IDs that it can accept requests from. After [JWT verification](./jwt-verification/index), `M2` would check if the value of `microservice_id` is whitelisted in its ID list. If not, it would reject the request.
- Allow any microservice to talk to `M2`. In this case, we could add:
    ```json
    {..., "source": "microservice", ...}
    ```
    Here `M2` would check that the value of `source` is `"microservice"` before serving the request. Else it would reject the request.

The advantage of the first method is that it is more secure. In a large microservice environment, working across several teams, it makes sense to isolate micorservices to create a stronger zero trust network.

The disadvantage is that each time a new microservice is added, the ID whitelist for `M2` would need to be updated (if necessary). The second method solves this disadvantage, but at the cost of slightly lower security.

## Code for creating a JWT

<WithWithoutSDK>
<TabItem value="withsdk">

First, we need to initialise the `JWT` recipe in the `supertokens.init` function call:

<BackendSDKTabs isSubTab={true}>
<TabItem value="nodejs">

```tsx
import supertokens from "supertokens-node"
import jwt from "supertokens-node/recipe/jwt"

supertokens.init({
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    supertokens: {
        connectionURI: "...", // location of the core
        apiKey: "..." // provide the core's API key if configured
    },
    recipeList: [
        // highlight-next-line
        jwt.init()
    ]
})
```

</TabItem>
<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/jwt"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	supertokens.Init(supertokens.TypeInput{
        AppInfo: supertokens.AppInfo{
            AppName: "...",
            WebsiteDomain: "...",
            APIDomain: "...",
        },
        Supertokens: &supertokens.ConnectionInfo{
            ConnectionURI: "...", // location of the core
            APIKey: "...", // provide the core's API key if configured
        },
		RecipeList: []supertokens.Recipe{
            // highlight-next-line
			jwt.Init(nil),
		},
	})
}
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import jwt

init(
    app_info=InputAppInfo(
        app_name="...",
        api_domain="...",
        website_domain="...",
    ),
    supertokens_config=SupertokensConfig(
        connection_uri="...", # location of the core
        api_key="..." # provide the core's API key if configured
    ),
    framework='django',
    recipe_list=[
        # highlight-next-line
        jwt.init(),
    ],
)
```

</TabItem>
</BackendSDKTabs>

:::important
- The value of `apiDomain` should be the domain part of the JWKS URL that will be used to verify the JWT (from `M2`). This should ideally be the domain of the microservice that has all the other SuperTokens' recipes initlised in them. 
- If this microservice does not initialise any other reicpe, the values of `appName` and `websiteDomain` don't matter.
:::

After this, you can use the JWT recipe to create your own JWT whenever required:

<BackendSDKTabs isSubTab={true}>
<TabItem value="nodejs">

```tsx
import jwt from "supertokens-node/recipe/jwt"

async function createJWT(payload: any) {
    let jwtResposne = await jwt.createJWT({
        ...payload,
        microservice_id: "M1" // we add this to identify the current microservice to the target one
    });
    if (jwtResposne.status === "OK") {
        // Send JWT as Authorization header to M2
        return jwtResposne.jwt;
    }
    throw new Error("Unable to create JWT. Should never come here.")
}
```

</TabItem>
<TabItem value="go">

```go
import (
	"fmt"

	"github.com/supertokens/supertokens-golang/recipe/jwt"
)

func main() {
	jwtResponse, err := jwt.CreateJWT(map[string]interface{}{
		"microservice_id": "M1",
		// ...additional payload
	}, nil)
	if err != nil {
		// handle error
	}
	jwtString := jwtResponse.OK.Jwt
	fmt.Println(jwtString)
    // Send JWT as Authorization header to M2
}
```

</TabItem>
<TabItem value="python">

<PythonSyncAsyncSubTabs>
<TabItem value="asyncio">

```python
from supertokens_python.recipe.jwt import asyncio
from supertokens_python.recipe.jwt.interfaces import CreateJwtOkResult

async def create_jwt():
    jwtResponse = await asyncio.create_jwt({
        "microservice_id": "M1",
        # ... extra payload
    })

    if isinstance(jwtResponse, CreateJwtOkResult):
        _ = jwtResponse.jwt
        # Send JWT as Authorization header to M2
    else:
        raise Exception("Unable to create JWT. Should never come here.")
```

</TabItem>
<TabItem value="syncio">

```python
from supertokens_python.recipe.jwt.syncio import create_jwt
from supertokens_python.recipe.jwt.interfaces import CreateJwtOkResult

jwtResponse = create_jwt({
    "microservice_id": "M1",
    # ... extra payload
})

if isinstance(jwtResponse, CreateJwtOkResult):
    jwtStr = jwtResponse.jwt
    # Send JWT as Authorization header to M2
else:
    raise Exception("Unable to create JWT. Should never come here.")
```

</TabItem>
</PythonSyncAsyncSubTabs>

</TabItem>
</BackendSDKTabs>

:::note
By default, the lifetime of the JWT will be a 100 years. You can pass a second argument to the `createJWT` function indicating a custom lifetime (in seconds) for the JWT.
:::

</TabItem>
<TabItem value="withoutsdk">

You can send a `HTTP` request to the core as follows:

```bash
curl --location --request POST '${connectionURI}/recipe/jwt' \
--header 'rid: jwt' \
--header 'api-key: ${APIKey}' \
--header 'Content-Type: application/json' \
--data-raw '{
  "payload": {
    "microservice_id": "M1",
    ...
  },
  "algorithm": "RS256",
  "jwksDomain": "${apiDomain}",
  "validity": ${validityInSeconds}
}'
```
- The value of `${connectionURI}` is the core's location
- `${APIKey}` is the API key to query the core. This is only needed if an API key is configured on the core.
- The value of `${apiDomain}` is the domain on which the JWKs URLs will be served from
- `${validityInSeconds}` is the lifetime of the JWT

An example response is as follows:
```json
{
    "status": "OK",
    "jwt": "eyJraWQiOiI0YTE5MjM5My05MTcxLTQyYzktOWRhNy0yYTE2OGVkMzdlYjEiLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL2FwaS50ZXN0LmNvbS8iLCJleHAiOjQ4MTMwMzE5MDEsImlhdCI6MTY1OTQzMTkwMCwibWljcm9zZXJ2aWNlX2lkIjoiTTEifQ.ja1Qy4EcslRpcVLAxJJFr8s_PmrqgCpaCUonaZd6JHwfsV-CA876vroQEwhstT8bednjJqGn-uJDmWI3cJRte4zvyNygK6hmJYVleka7Ae8scqdv6cRiM4ZPoHh0-sflaiXBiJHH3rjKTkuj1CBrzifgcCmg6f2X7iDqL3P0Kvw2dpvx-nm26I3jeAKELsm2DuuwZ0hsLzCGiWQhmc5EKJRK8UOYROXzsUAgvUk04KYYsbN8_t22L3H9fAWEKKDkxtTzlQiYMVc7xFH_F_ZxQyN8JESiyye-vkd5KXiaVYword0CdVTres5RrWUlDOP0DkrCFPcIRgzu_bChIIpFdA"
}

```

</TabItem>
</WithWithoutSDK>