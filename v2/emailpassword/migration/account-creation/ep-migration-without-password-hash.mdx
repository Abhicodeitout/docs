
---
id: ep-migration-without-password-hash
title: User Creation without password hahes
hide_title: true
---
# User Creation without password hahes

:::caution
The recommended method for migrating users to SuperTokens is by [importing users with their password hashes](./user-creation).
You should only use the following method if you do not have access to your user's password hashes but still have access to your previous identity provider
:::

In this guide we will be overriding the SuperTokens login function so that if a user logs into your app with account credentials registered in another provider, their user data will be retrieved from said provider and a new SuperTokens account will be created.

:::info
The following code is implemented for Nodejs, but, you can apply the same logic in your own tech stack.
:::




```tsx
import SuperTokens from "supertokens-node"
import EmailPassword from "supertokens-node/recipe/emailpassword"
import Session from "supertokens-node/recipe/session";

EmailPassword.init({
    override: {
        functions: (originalImplementaion) => {
            return {
                ...originalImplementaion,
                // EmailPassword Login function modification
                signIn: async function (input) {
                    // Check if the user exists in the external provider
                    if (await doesUserExistInExternalProvider(input.email)) {
                        
                        // retrieve user from SuperTokens
                        let supertokensUser = await EmailPassword.getUserByEmail(input.email, input.userContext);
                        // Check if user exists in SuperTokens
                        if (supertokensUser === undefined) {
                            // EmailPassword user with the input credentials does not exist in SuperTokens
                            // Validate users credentials in provider
                            // @ts-ignore
                            let externalUserInfo = await validateAndGetUserInfoFromExternalProvider(input.email, input.password)
                            if (externalUserInfo === undefined) {
                                // Credentials are incorrect
                                return {
                                    status: "WRONG_CREDENTIALS_ERROR"
                                }
                            }
                            // Call the signup function to create a new SuperTokens user.
                            let signUpResponse = await EmailPassword.signUp(input)
                            if (signUpResponse.status !== "OK") {
                                return {
                                    status: "WRONG_CREDENTIALS_ERROR",
                                };
                            }
                            // Map the external provider's userId to the SuperTokens userId
                            // If you have not stored the users external userId in your tables, you can ignore this step
                            await SuperTokens.createUserIdMapping({ superTokensUserId: signUpResponse.user.id, externalUserId: externalUserInfo.user_id})
                            // Set the userId in the response to use the provider's userId
                            // If you have not stored the users external userId in your tables, you can ignore this step
                            signUpResponse.user.id = externalUserInfo.user_id
                            
                            return signUpResponse;
                        }
                    } 
                    return originalImplementaion.signIn(input)
                },
            }
        },
        apis: (originalImplementation) => {
            return {
                ...originalImplementation,
                generatePasswordResetTokenPOST: async (input) => {
                    if(originalImplementation.generatePasswordResetTokenPOST === undefined){
                        throw Error("Should not come here")
                    }

                     // retrive email from input
                     let email = input.formFields.find(i => i.id === "email");

                     if(email === undefined){
                         throw new Error("Should never come here")
                     }

                     // Check if the user exists in SuperTokens
                     let supertokensUser = await EmailPassword.getUserByEmail(email.value, input.userContext);
                     if(supertokensUser === undefined){
                        // check if the user exists in the external provider
                        // @ts-ignore
                        let externalUserInfo = await retrieveUserDataFromExternalProvider(email.value)
                        if(externalUserInfo){
                            // create a SuperTokens account for the user, we will generate the account with a temporary password
                            let tempPassword = generatePassword(); 
                            let signUpResponse = await EmailPassword.signUp(email.value, tempPassword, input.userContext);

                            if(signUpResponse.status === "OK"){
                                // if user is succesfully created  we will map the external id to their SuperTokens Id. 
                                // If you have not stored the users external userId in your tables, you can ignore this step
                                SuperTokens.createUserIdMapping({
                                    superTokensUserId: signUpResponse.user.id,
                                    externalUserId: externalUserInfo.user_id
                                })   
                            }
                        }  
                     }
                    return originalImplementation.generatePasswordResetTokenPOST(input);
                }
            }
        }
    },
})
```