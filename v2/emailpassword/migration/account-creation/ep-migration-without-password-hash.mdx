---
id: ep-migration-without-password-hash
title: User Creation without password hashes
hide_title: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import TabItem from '@theme/TabItem';

# User Creation without password hashes

:::caution
The recommended method for migrating users to SuperTokens is by [importing users with their password hashes](./user-creation).
You should only use the following method if you do not have access to your user's password hashes and still have access to your previous identity provider.
:::

SuperTokens also supports the "**just in time**" user migration strategy for when password hashes cannot be exported from your legacy provider.

We will need to make the following customizations to SuperTokens authentication flows to support this strategy:

- **Step 1) Prevent signups from users who exist in the external provider.**
  - To prevent loss of data during migration we block signups from users who have existing accounts with the external provider.
- **Step 2) Create a SuperTokens account for users trying to sign in if they have an account with the external provider.**
  -  We will modify the signin flow to check if the user signing in has an existing account with the external provider. If they do and the input credentials are valid, we create a SuperTokens user and import their user data.
- **Step 3) Create a SuperTokens account for users who have an account with the external provider but have forgotten their password.**
  - Some users who have an account with the external provider and not with SuperTokens may have forgotten their passwords and will trigger the password reset flow.
   Since SuperTokens requires an account to exist to perform a password reset, we will need to modify the password reset flow to check that if the user needs to be migrated. If they do, we create a SuperTokens account with a temporary password, import their user data and continue the password reset flow.
   - To ensure that users can only signin once they succesfully reset their passwords we add the `isUsingTemporaryPassword` flag to the accounts metadata. We will also modify the signin flow to block signins from accounts with this metadata.
- **Step 4) Remove the `isUsingTemporaryPassword` flag on successful password reset**
  - Once the password has been successfully reset we check if the user has the `isUsingTemporaryPassword` flag set in the metadata. If they do we will clear the flag from the user's metadata.

## Step 1) Prevent signups from users who exist in the external provider

To implement this change we will override the function that handles signup when initializing the `EmailPassword` recipe on the backend.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import EmailPassword from "supertokens-node/recipe/emailpassword"

EmailPassword.init({
    override: {
        functions: (originalImplementaion) => {
            return {
                ...originalImplementaion,
                signUp: async function(input){
                    // Check if the user signing in exists in the external provider
                    if(await doesUserExistInExternalProvider(input.email)){
                        
                        // Return status "EMAIL_ALREADY_EXISTS_ERROR" since the user exists in the external provider
                        return {
                            status: "EMAIL_ALREADY_EXISTS_ERROR"
                        }
                    }
                    return originalImplementaion.signUp(input);
                }
            }
        },
    },
})

async function doesUserExistInExternalProvider(email: string): Promise<boolean> {
    // TODO: Check if user with the input email exists in the external provider
    return false;
}
```

</TabItem>
</BackendSDKTabs>

We modify the `signUp` flow to first check if the user signing up has an account with the external provider. If they do we return a `EMAIL_ALREADY_EXISTS_ERROR`

## Step 2) Create a SuperTokens account for users trying to sign in if they have an account with the external provider

To implement this flow we will override the function that handles login when initializing the `EmailPassword` recipe on the backend.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node"
import EmailPassword from "supertokens-node/recipe/emailpassword"
import EmailVerification from "supertokens-node/recipe/emailverification"
import UserMetadata from "supertokens-node/recipe/usermetadata"

EmailPassword.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
                signIn: async function (input) {
                    // Check if the user exists in the external provider
                    if (await doesUserExistInExternalProvider(input.email)) {
                        // Check if the user exists in SuperTokens
                        let supertokensUser = await EmailPassword.getUserByEmail(input.email, input.userContext);
                        if (supertokensUser === undefined) {
                            // EmailPassword user with the input credentials does not exist in SuperTokens
                            // Check if the input credentials are valid in the external provider
                            let legacyUserInfo = await validateAndGetUserInfoFromExternalProvider(input.email, input.password)
                            if (legacyUserInfo === undefined) {
                                // credentials are incorrect
                                return {
                                    status: "WRONG_CREDENTIALS_ERROR"
                                }
                            }
                            // Call the signup function to create a new SuperTokens user.
                            let signUpResponse = await EmailPassword.signUp(input.email, input.password, input.userContext)
                            if (signUpResponse.status !== "OK") {
                                throw new Error("Should never come here")
                            }

                            // Map the external provider's userId to the SuperTokens userId
                            await SuperTokens.createUserIdMapping({ superTokensUserId: signUpResponse.user.id, externalUserId: legacyUserInfo.user_id })
                            // Set the userId in the response to use the provider's userId
                            signUpResponse.user.id = legacyUserInfo.user_id

                            // We will also need to set the email verification status of the user
                            if (legacyUserInfo.isEmailVerified) {
                                // Generate an email verification token for the user
                                let generateEmailVerificationTokenResponse = await EmailVerification.createEmailVerificationToken(signUpResponse.user.id, input.email, input.userContext);

                                if (generateEmailVerificationTokenResponse.status === "OK") {
                                    // Verify the user's email
                                    await EmailVerification.verifyEmailUsingToken(generateEmailVerificationTokenResponse.token, input.userContext);
                                }
                            }

                            // Now that the user has been successfully imported we can delete the user from the external provider
                            // Note: This step is optional but it will reduce an unnecessary API call during subsequent sign in requests from the same user
                            await deleteUserFromExternalProvider(signUpResponse.user.id)

                            return signUpResponse;
                        }
                        // Check if the user signing in has a temporary password
                        let userMetadata = await UserMetadata.getUserMetadata(supertokensUser.id, input.userContext)
                        if(userMetadata.status === "OK" && userMetadata.metadata.isUsingTemporaryPassword){
                            // Check if the input credentials are valid in the external provider
                            let legacyUserInfo = await validateAndGetUserInfoFromExternalProvider(input.email, input.password);
                            if(legacyUserInfo){
                                // Update the user's password with the correct password
                                EmailPassword.updateEmailOrPassword({
                                    userId: supertokensUser.id,
                                    password: input.password
                                })

                                // Update the user's metadata to remove the isUsingTemporaryPassword flag
                                UserMetadata.updateUserMetadata(supertokensUser.id, {isUsingTemporaryPassword: null})

                                // Now that the user has been successfully imported we can delete the user from the external provider
                                // Note: This step is optional but it will reduce an unnecessary API call during subsequent sign in requests from the same user
                                await deleteUserFromExternalProvider(supertokensUser.id)

                                return {
                                    status: "OK",
                                    user: supertokensUser
                                }
                            }
                        }
                    }
                    return originalImplementation.signIn(input)
                },
            }
        },
    },
})

async function doesUserExistInExternalProvider(email: string): Promise<boolean> {
    // TODO: Check if user with the input email exists in the external provider
    return false;
}

async function validateAndGetUserInfoFromExternalProvider(email: string, password: string): Promise<{
    user_id: string,
    isEmailVerified: boolean
} | undefined> {
    // TODO: Validate the input credentials against the external authentication provider. If the credentials are valid return the user info.
    return undefined
}

async function deleteUserFromExternalProvider(userId: string): Promise<void>{
    // TODO: Delete user with the input userId from the external provider
}
```

</TabItem>
</BackendSDKTabs>

The code above overrides the `signIn` function with the following changes to achieve "**just in time**" migration:
- The first step is to determine if the user signing in needs to be migrated or not. We do this by checking if a user with the input email exists in the external auth provider and SuperTokens.
If the user exists in the external auth provider and does not exist SuperTokens, we can determine that this user needs to be migrated.
- The next step is to validate the input credentials against the external provider. If the credentials are invalid we will return a `WRONG_CREDENTIALS_ERROR`.
If the credentials are valid we can call the SuperTokens `signUp` function with the input credentials to create a new SuperTokens user.
- We now map the external `userId` to the SuperTokens `userId`. This will allow SuperTokens functions to refrence the user with the external `userId`.
- Depending on the email verification status of the user in the external provider we will also verify the user's email in SuperTokens.
- Finally, since the user has been successfully imported we can  delete the user from the external provider. This step is optional

Additional checks will have to be made in case the user exists in both the external provider and SuperTokens: 
- Check if the user has the `isUsingTemporaryPassword` flag set in their metadata.
This flag is set in the password reset flow and it's relevance is described in [Step 3](#step-3-override-the-password-reset-flow).
- If the user has this flag, we check if the input credentials to the `signIn` function is valid in the external provider. 
If they are valid, we update the users account with the password, remove the `isUsingTemporaryPassword` flag from it's metadata and delete the user from the external provider.
If the credentials are invalid we return a `WRONG_CREDENTIALS_ERROR`. 

## Step 3) Create a SuperTokens account for users who have an account with the external provider but have forgotten their password.

Some users who do not have a SuperTokens account but have an existing account with the external provider may have forgotten their passwords and will initiate a password reset.
We will need to modify SuperTokens' reset password API to account for this scenarion since password resets require an existing SuperTokens account. 

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node"
import EmailPassword from "supertokens-node/recipe/emailpassword"
import EmailVerification from "supertokens-node/recipe/emailverification"
import UserMetadata from "supertokens-node/recipe/usermetadata"

EmailPassword.init({
    override: {
        functions: (originalImplementaion) => {
            return {
                ...originalImplementaion
                // TODO: implentation details in previous step
            }
        },
        apis: (originalImplementation) => {
            return {
                ...originalImplementation,
                generatePasswordResetTokenPOST: async (input) => {
                    // retrieve the email from the input
                    let email = input.formFields.find(i => i.id === "email")!.value;

                    // Check if the user exists in SuperTokens
                    let supertokensUser = await EmailPassword.getUserByEmail(email, input.userContext);
                    if (supertokensUser === undefined) {
                        // check if the user exists in the external provider
                        let legacyUserInfo = await retrieveUserDataFromExternalProvider(email)
                        if (legacyUserInfo) {
                            // create a SuperTokens account for the user with a temporary password
                            let tempPassword = await generatePassword();
                            let signUpResponse = await EmailPassword.signUp(email, tempPassword, input.userContext);

                            if (signUpResponse.status === "OK") {

                                // Map the external provider's userId to the SuperTokens userId
                                await SuperTokens.createUserIdMapping({
                                    superTokensUserId: signUpResponse.user.id,
                                    externalUserId: legacyUserInfo.user_id
                                })

                                // We will also need to set the email verification status of the user
                                if (legacyUserInfo.isEmailVerified) {
                                    // generate an email verification token for the user
                                    let generateEmailVerificationTokenResponse = await EmailVerification.createEmailVerificationToken(legacyUserInfo.user_id, email, input.userContext);

                                    if (generateEmailVerificationTokenResponse.status === "OK") {
                                        // verify the user's email
                                        await EmailVerification.verifyEmailUsingToken(generateEmailVerificationTokenResponse.token, input.userContext);
                                    }
                                }

                                // We also need to identify that the user is using a temporary password. We do through the userMetadata recipe
                                UserMetadata.updateUserMetadata(legacyUserInfo.user_id,{isUsingTemporaryPassword: true})

                            } else {
                                throw new Error("Should never come here")
                            }
                        }
                    }
                    return originalImplementation.generatePasswordResetTokenPOST!(input);
                }
            }
        }
    }
})

async function generatePassword(): Promise<string> {
    // TODO: generate a random password 
    return ""
}

async function retrieveUserDataFromExternalProvider(email: string): Promise<{
    user_id: string,
    isEmailVerified: boolean
} | undefined> {
    // TODO: retrieve user data if a user with the input email exists in the external provider.
    return undefined;
}
```

</TabItem>
</BackendSDKTabs>

The code above overrides the `generatePasswordResetTokenPOST` API with the following changes to achieve "**just in time**" migration:
- Similar to [Step 1](#step-1-override-the-login-flow), we need to determine whether to migrate the user or not. To do this we check if the user exists in the external provider and SuperTokens.
If the user exists in the external provider and does not exist in SuperTokens, we can determine that this user needs to be migrated.
- The next step is to create a SuperTokens account with a temporary password, the password can be a random string since it will be reset by the user when they complete the reset password flow.
- We now map the external `userId` to the SuperTokens `userId`. This will allow SuperTokens functions to refrence the user with the external `userId`.
- Depending on the email verification status of the user in the external provider we will also verify the user's email in SuperTokens.
- We assign the `isUsingTemporaryPassword` flag to user's metadata since the account was generated with a temporary password. This is done to prevent signins until the password is successfully reset.

## Step 4) Remove the `isUsingTemporaryPassword` flag on successful password reset

If the password reset flow is successfully completed we will need to check if the user has `isUsingTemporaryPassword` set in their metadata and remove it if it exists.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import EmailPassword from "supertokens-node/recipe/emailpassword"
import UserMetadata from "supertokens-node/recipe/usermetadata"

EmailPassword.init({
    override: {
        functions: (originalImplementaion) => {
            return {
                ...originalImplementaion
                // TODO: implentation details in previous step
            }
        },
        apis: (originalImplementation) => {
            return {
                ...originalImplementation,
                // TODO: implementation details in previous step
                passwordResetPOST: async function (input) {
                    let response = await originalImplementation.passwordResetPOST!(input);
                    if (response.status === "OK") {
                        let usermetadata = await UserMetadata.getUserMetadata(response.userId!, input.userContext)
                        if (usermetadata.status === "OK" && usermetadata.metadata.isUsingTemporaryPassword) {
                            // Since the password reset we can remove the isUsingTemporaryPassword flag
                            await UserMetadata.updateUserMetadata(response.userId!, { isUsingTemporaryPassword: null })

                            // Since the user has been successfully imported into SuperTokens, we can now delete the user from the external provider
                            // Note: This step is optional but it will reduce an unnecessary API call during subsequent sign in requests from the same user
                            await deleteUserFromExternalProvider(response.userId!)

                        }
                    }
                    return response
                }
            }
        }
    }
})

async function deleteUserFromExternalProvider(userId: string): Promise<void>{
    // TODO: Delete user with the input userId from the external provider
}
```
</TabItem>
</BackendSDKTabs>

The code above overrides the `passwordResetPOST` API and is a continuation of the password reset flow:
- On a successful password reset we check if the user has the `isUsingTemporaryPassword` flag set in their metadata. If it exists we remove the flag from the metadata and delete the user from the external provider.
