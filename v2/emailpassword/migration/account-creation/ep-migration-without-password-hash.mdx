---
id: ep-migration-without-password-hash
title: User Creation without password hahes
hide_title: true
---

# User Creation without password hahes


:::caution
The recommended method for migrating users to SuperTokens is by [importing users with their password hashes](./user-creation).
You should only use the following method if you do not have access to your user's password hashes and still have access to your previous identity provider.
:::

Supertokens also supports the "**just in time**" user migration strategy for when password hashes cannot be exported from your legacy provider.
In this approach, the login flow is modified so that if a legacy user tries to authenticate, SuperTokens will check if the user exists in the legacy provider and whether the input credentials are valid.
If the user exists in the leagacy provider and the credentials are valid, SuperTokens will retrieve the user data from the legacy provider and create a corresponding SuperTokens user account. 


## Step 1) Override Login flow to support user migration

To implement this flow we will first override the function that login when initializing the `EmailPassword` recipe on the backend.

:::info
The following code is implemented for Nodejs, but, you can apply the same logic in your own tech stack.
:::


```tsx
import SuperTokens from "supertokens-node"
import EmailPassword from "supertokens-node/recipe/emailpassword"
import EmailVerification from "supertokens-node/recipe/emailverification"

EmailPassword.init({
    override: {
        functions: (originalImplementaion) => {
            return {
                ...originalImplementaion,
                // EmailPassword Login function modification
                signIn: async function (input) {
                    // Check if the user exists in the external provider
                    // @ts-ignore
                    if (await doesUserExistInExternalProvider(input.email)) {
                        
                        // retrieve user from SuperTokens
                        let supertokensUser = await EmailPassword.getUserByEmail(input.email, input.userContext);
                        // Check if user exists in SuperTokens
                        if (supertokensUser === undefined) {
                            // EmailPassword user with the input credentials does not exist in SuperTokens
                            // TODO: validateAndGetUserInfoFromLegacyProvider() is a function defined by you
                            // @ts-ignore
                            let legacyUserInfo = await validateAndGetUserInfoFromLegacyProvider(input.email, input.password)
                            if (legacyUserInfo === undefined) {
                                // Credentials are incorrect
                                return {
                                    status: "WRONG_CREDENTIALS_ERROR"
                                }
                            }
                            // Call the signup function to create a new SuperTokens user.
                            let signUpResponse = await EmailPassword.signUp(input.email, input.password, input.userContext)
                            if (signUpResponse.status !== "OK") {
                                return {
                                    status: "WRONG_CREDENTIALS_ERROR",
                                };
                            }

                            // We will also need to set the email verification status of the user
                            if(legacyUserInfo.isEmailVerified){
                                // generate an email verification token for the user
                                let generateEmailVerificationTokenResponse = await  EmailVerification.createEmailVerificationToken(signUpResponse.user.id, input.email, input.userContext);

                                if(generateEmailVerificationTokenResponse.status === "OK"){
                                    // verify the user's email
                                    await EmailVerification.verifyEmailUsingToken(generateEmailVerificationTokenResponse.token, input.userContext);
                                }
                            }

                            // Map the external provider's userId to the SuperTokens userId
                            // If you have not stored the users external userId in your tables, you can ignore this step
                            await SuperTokens.createUserIdMapping({ superTokensUserId: signUpResponse.user.id, externalUserId: legacyUserInfo.user_id})
                            // Set the userId in the response to use the provider's userId
                            // If you have not stored the users external userId in your tables, you can ignore this step
                            signUpResponse.user.id = legacyUserInfo.user_id

                            // TODO: You could also assign Roles and Metadata to the user at this point
                            
                            return signUpResponse;
                        }
                    } 
                    return originalImplementaion.signIn(input)
                },
            }
        },
    },
})

```

## Step 2) Override password reset flow to support user migration

You will also need to account for user's who have forgotten their passwords. We will need to modify the reset password flow to account for this.

```tsx
import SuperTokens from "supertokens-node"
import EmailPassword from "supertokens-node/recipe/emailpassword"
import EmailVerification from "supertokens-node/recipe/emailverification"

EmailPassword.init({
    override: {
        functions: (originalImplementaion) => {
            return {
                ...originalImplementaion
                // TODO: implentation details in previous step
            }
        },
        apis: (originalImplementation) => {
            return {
                ...originalImplementation,
                generatePasswordResetTokenPOST: async (input) => {
                    if(originalImplementation.generatePasswordResetTokenPOST === undefined){
                        throw Error("Should not come here")
                    }

                     // retrive email from input
                     let email = input.formFields.find(i => i.id === "email");

                     if(email === undefined){
                         throw new Error("Should never come here")
                     }

                     // Check if the user exists in SuperTokens
                     let supertokensUser = await EmailPassword.getUserByEmail(email.value, input.userContext);
                     if(supertokensUser === undefined){
                        // check if the user exists in the external provider
                        // TODO: retrieveUserDataFromLegacyProvider() is a function defined by you
                        // @ts-ignore
                        let legacyUserInfo = await retrieveUserDataFromLegacyProvider(email.value)
                        if(legacyUserInfo){
                            // create a SuperTokens account for the user, we will generate the account with a temporary password
                            // @ts-ignore
                            let tempPassword = generatePassword(); 
                            let signUpResponse = await EmailPassword.signUp(email.value, tempPassword, input.userContext);

                            if(signUpResponse.status === "OK"){
                                
                                // We will also need to set the email verification status of the user
                                if(legacyUserInfo.isEmailVerified){
                                    // generate an email verification token for the user
                                    let generateEmailVerificationTokenResponse = await  EmailVerification.createEmailVerificationToken(signUpResponse.user.id, email.value, input.userContext);

                                    if(generateEmailVerificationTokenResponse.status === "OK"){
                                        // verify the user's email
                                        await EmailVerification.verifyEmailUsingToken(generateEmailVerificationTokenResponse.token, input.userContext);
                                    }
                                }

                                // if user is succesfully created  we will map the external id to their SuperTokens Id. 
                                // If you have not stored the users external userId in your tables, you can ignore this step
                                // @ts-ignore
                                SuperTokens.createUserIdMapping({
                                    superTokensUserId: signUpResponse.user.id,
                                    externalUserId: legacyUserInfo.user_id
                                })
                                
                                // TODO: You could also assign Roles and Metadata to the user at this point
                            }
                        }  
                     }
                    return originalImplementation.generatePasswordResetTokenPOST(input);
                }
            }
        }
    }
})
```