---
id: guide
title: Guide
hide_title: true
---

<!-- COPY DOCS -->
<!-- ./session/advanced-customizations/localstorage-example/guide.mdx -->
# Step-by-step guide

## Backend

### 1. Allow the custom header on requests
First, we need to allow the frontend to send the `st-cookie` header we chose to transfer the tokens.

<BackendSDKTabs>
<TabItem value="nodejs">

```jsx
app.use(
    cors({
        origin: websiteDomain,
        //highlight-start
        allowedHeaders: ["content-type", "st-cookie", ...supertokens.getAllCORSHeaders()],
        //highlight-end
        methods: ["GET", "PUT", "POST", "DELETE"],
        credentials: true,
    })
);
```
</TabItem>
</BackendSDKTabs>

### 2. Adding a helper
Then, we need to add a helper function that will handle copying the `Set-Cookie` header into our custom header and also add that header
to the `access-control-expose-headers` list so that the frontend can access it on CORS requests.

<BackendSDKTabs>
<TabItem value="nodejs">

```jsx
function updateHeaders(res) {
    if (!res.headersSent) {
        const cookies = res.getHeader("Set-Cookie");
        if (cookies) {
            // We need to copy the Set-Cookie header into another one, since Set-Cookie is not accessible on the frontend
            res.setHeader("st-cookie", cookies);
            // We need to make the new header accessible to the frontend
            res.setHeader(
                "access-control-expose-headers",
                `st-cookie, ${res.getHeader("access-control-expose-headers")}`
            );

            // This is not strictly necessary
            res.removeHeader("Set-Cookie");
        }
    }
}
```
</TabItem>
</BackendSDKTabs>

### 3. Send the tokens using a custom header

Finally, we need to override most of the functions and APIs of the `Session` recipe to have them use the header enabled in the first step and to 
use the helper function defined in the second step to send tokens to the frontend.

<BackendSDKTabs>
<TabItem value="nodejs">

```jsx
supertokens.init({
    supertokens: {...},
    appInfo: {...},
    recipeList: [
        ...,
        //highlight-start
        Session.init({
            // CSRF protection is not necessary in this case, because there are no cookies that would be automatically sent
            antiCsrf: "NONE",
            override: {
                functions: (origImpl) => {
                    return {
                        ...origImpl,

                        createNewSession: async (input) => {
                            const session = await origImpl.createNewSession(input);

                            updateHeaders(session.res);

                            return session;
                        },

                        refreshSession: async (input) => {
                            const session = await origImpl.refreshSession(input);

                            updateHeaders(session.res);

                            return session;
                        },

                        getSession: async (input) => {
                            const stCookies = input.req.headers["st-cookie"];

                            if (stCookies) {
                                input.req.headers["cookie"] = input.req.headers["st-cookie"];
                            }
                            const res = origImpl.getSession(input);

                            updateHeaders(input.res);

                            return res;
                        },
                    };
                },

                apis: (origImpl) => {
                    return {
                        ...origImpl,

                        signOutPOST: async (input) => {
                            await origImpl.signOutPOST(input);

                            updateHeaders(input.options.res);
                        },

                        verifySession: async (input) => {
                            const stCookies = input.options.req.headers["st-cookie"];

                            if (stCookies) {
                                input.options.req.headers["cookie"] = input.options.req.headers["st-cookie"];
                            }

                            await origImpl.verifySession(input);

                            updateHeaders(input.options.res);
                        },

                        refreshPOST: async (input) => {
                            const stCookies = input.options.req.headers["st-cookie"];

                            if (stCookies) {
                                input.options.req.headers["cookie"] = input.options.req.headers["st-cookie"];
                            }

                            await origImpl.refreshPOST(input);

                            updateHeaders(input.options.res);
                        },
                    };
                },
            },
        }),
        //highlight-end
    ],
});
```
</TabItem>
</BackendSDKTabs>

## Frontend

### 1. Adding a helper to store cookies
First, we need to add a helper function that will process the custom header and store the cookies in the proper format.

<FrontendSDKTabs>
<TabItem value="reactjs">

```jsx
function setCookiesInLocalstorage(respCookies) {
    if (respCookies) {
        // Split and parse cookies received
        const respCookieMap = parseSetCookieString(splitCookiesString(respCookies), { decodeValues: false, map: true });

        // Check if we have anything stored already
        const localstorageCookies = localStorage.getItem("st-cookie");
        if (localstorageCookies !== null) {
            // Split and parse cookies we have in stored previously
            const splitStoredCookies = localstorageCookies.split("; ").map((cookie) => cookie.split("="));

            for (const [name, value] of splitStoredCookies) {
                // Keep old cookies if they weren't overwritten
                if (respCookieMap[name] === undefined) {
                    respCookieMap[name] = { name, value };
                }
            }
        }

        // Save the combined cookies in a the format of a Cookie header
        // Please keep in mind that these have no expiration and lack many of the things done automatically for cookies
        // Many of these features can be implemented, but they are out of scope for this example
        localStorage.setItem(
            "st-cookie",
            Object.values(respCookieMap)
                .map((cookie) => `${cookie.name}=${cookie.value}`)
                .join("; ")
        );
    }
}
```
</TabItem>
<TabItem value="vanillajs">

```jsx
function setCookiesInLocalstorage(respCookies) {
    if (respCookies) {
        // Split and parse cookies received
        const respCookieMap = parseSetCookieString(splitCookiesString(respCookies), { decodeValues: false, map: true });

        // Check if we have anything stored already
        const localstorageCookies = localStorage.getItem("st-cookie");
        if (localstorageCookies !== null) {
            // Split and parse cookies we have in stored previously
            const splitStoredCookies = localstorageCookies.split("; ").map((cookie) => cookie.split("="));

            for (const [name, value] of splitStoredCookies) {
                // Keep old cookies if they weren't overwritten
                if (respCookieMap[name] === undefined) {
                    respCookieMap[name] = { name, value };
                }
            }
        }

        // Save the combined cookies in a the format of a Cookie header
        // Please keep in mind that these have no expiration and lack many of the things done automatically for cookies
        // Many of these features can be implemented, but they are out of scope for this example
        localStorage.setItem(
            "st-cookie",
            Object.values(respCookieMap)
                .map((cookie) => `${cookie.name}=${cookie.value}`)
                .join("; ")
        );
    }
}
```
</TabItem>
</FrontendSDKTabs>

### 2. Replace global fetch
Then, we need to replace the global fetch to make use of the custom header.
We need to do this because fetch is used internally by the SuperTokens SDK, and we have no other way of getting access to response headers.

:::important
- This has to be done before calling `SuperTokens.init`
:::

<FrontendSDKTabs>
<TabItem value="reactjs">

```jsx
const origFetch = window.fetch;
window.fetch = async (input, init) => {
    // Check if the we need to add the cookies
    if (isApiDomain(input.url || input)) {
        if (init === undefined) {
            init = {};
        }
        if (init.headers === undefined) {
            init.headers = {};
        }

        // Simply add the stored string into a header, it's already in the correct format.
        const stCookies = localStorage.getItem("st-cookie");
        if (stCookies) {
            init.headers["st-cookie"] = stCookies;
        }
    }

    const res = await origFetch(input, init);

    // Check if the we need to process the cookies in the response
    if (isApiDomain(input.url || input)) {
        const respCookies = res.headers.get("st-cookie");

        setCookiesInLocalstorage(respCookies);
    }
    return res;
};

```
</TabItem>
<TabItem value="vanillajs">

```jsx
const origFetch = window.fetch;
window.fetch = async (input, init) => {
    // Check if the we need to add the cookies
    if (isApiDomain(input.url || input)) {
        if (init === undefined) {
            init = {};
        }
        if (init.headers === undefined) {
            init.headers = {};
        }

        // Simply add the stored string into a header, it's already in the correct format.
        const stCookies = localStorage.getItem("st-cookie");
        if (stCookies) {
            init.headers["st-cookie"] = stCookies;
        }
    }

    const res = await origFetch(input, init);

    // Check if the we need to process the cookies in the response
    if (isApiDomain(input.url || input)) {
        const respCookies = res.headers.get("st-cookie");

        setCookiesInLocalstorage(respCookies);
    }
    return res;
};

```
</TabItem>
</FrontendSDKTabs>

### 3. Clearing cookies on logout

Finally, we need to add an event handler that will clear the cookies on logout

<FrontendSDKTabs>
<TabItem value="reactjs">

```jsx
SuperTokens.init({
    appInfo: {...},
    recipeList: [
        ...,
        Session.init({
            //highlight-start
            onHandleEvent: (recipeEvent) => {
                // Clear all cookies if the session expired and on signout
                if (["SIGN_OUT", "UNAUTHORISED"].includes(recipeEvent.action)) {
                    localStorage.removeItem("st-cookie");
                }
            },
            //highlight-end
        }),
    ],
});
```
</TabItem>
<TabItem value="vanillajs">

```jsx
SuperTokens.init({
    appInfo: {...},
    recipeList: [
        ...,
        Session.init({
            //highlight-start
            onHandleEvent: (recipeEvent) => {
                // Clear all cookies if the session expired and on signout
                if (["SIGN_OUT", "UNAUTHORISED"].includes(recipeEvent.action)) {
                    localStorage.removeItem("st-cookie");
                }
            },
            //highlight-end
        }),
    ],
});
```
</TabItem>
</FrontendSDKTabs>

4. An optional step is to add an `axios` interceptor

:::important
- This step is only applicable if you are using `axios`
:::

<FrontendSDKTabs>
<TabItem value="reactjs">

```jsx
axios.interceptors.request.use(
    function (config) {
        // Check if the we need to add the cookies
        if (isApiDomain(config.url)) {
            const stCookies = localStorage.getItem("st-cookie");
            if (stCookies) {
                // Simply add the stored string into a header, it's already in the correct format.
                config.headers["st-cookie"] = stCookies;
            }
        }
        return config;
    },
    function (error) {
        return Promise.reject(error);
    }
);

axios.interceptors.response.use(
    function (res) {
        // Check if the we need to process the cookies in the response
        if (isApiDomain(res.config.url)) {
            const respCookies = res.headers["st-cookie"];

            setCookiesInLocalstorage(respCookies);
        }
        return res;
    },
    // We need to process error responses as well
    function (error) {
        // Check if the we need to process the cookies in the response
        if (isApiDomain(error.config.url)) {
            const res = error.response;
            const respCookies = res.headers["st-cookie"];

            setCookiesInLocalstorage(respCookies);
        }
        return Promise.reject(error);
    }
);
```
</TabItem>
<TabItem value="vanillajs">

```jsx
axios.interceptors.request.use(
    function (config) {
        // Check if the we need to add the cookies
        if (isApiDomain(config.url)) {
            const stCookies = localStorage.getItem("st-cookie");
            if (stCookies) {
                // Simply add the stored string into a header, it's already in the correct format.
                config.headers["st-cookie"] = stCookies;
            }
        }
        return config;
    },
    function (error) {
        return Promise.reject(error);
    }
);

axios.interceptors.response.use(
    function (res) {
        // Check if the we need to process the cookies in the response
        if (isApiDomain(res.config.url)) {
            const respCookies = res.headers["st-cookie"];

            setCookiesInLocalstorage(respCookies);
        }
        return res;
    },
    // We need to process error responses as well
    function (error) {
        // Check if the we need to process the cookies in the response
        if (isApiDomain(error.config.url)) {
            const res = error.response;
            const respCookies = res.headers["st-cookie"];

            setCookiesInLocalstorage(respCookies);
        }
        return Promise.reject(error);
    }
);
```
</TabItem>
</FrontendSDKTabs>

