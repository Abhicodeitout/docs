---
id: emailpassword-changes
title: Changes to the emailpassword flow
hide_title: true
show_ui_switcher: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import TabItem from '@theme/TabItem';

# Changes to the emailpassword flow

Our approach will be to replace the `email` field in SuperTokens with the username field. This will enable username and password login as well as enforce username uniqueness.

Then we will save the optional email against the userID of the user and use that during sign in and reset password flows. The mapping of email to userID will need to be handled by you and stored in your own database. We will create place holder functions in the code snippets below for you to implement them.

## Modifying the default email validator function
Whent the sign up / in API is called on the backend, SuperTokens first verifies the syntax of the input email. Since we want to replace emails with usernames, we need to change that function to allow for any `string`. We can do this in the following way:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import EmailPassword from "supertokens-node/recipe/emailpassword";

SuperTokens.init({
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    supertokens: {
        connectionURI: "...",
    },
    recipeList: [
        EmailPassword.init({
            signUpFeature: {
                formFields: [{
                    id: "email",
                    validate: async (value) => {
                        if (typeof value !== "string") {
                            return "Please provide a string input."
                        }
                        if (value.length < 3) {
                            return "Usernames must be at least 3 characters long."
                        }
                        if (!value.match(/^[a-z0-9_-]+$/)) {
                            return "Username must contain only alphanumeric, underscore or hyphen characters."
                        }
                    }
                }]
            }
        })
    ]
});
```

</TabItem>
<TabItem value="go">

```go
TODO
```

</TabItem>
<TabItem value="python">

```python
TODO
```

</TabItem>
</BackendSDKTabs>

- The new `validate` function checks if the input username has at least three characters and contains only alphanumeric, underscore or hyphen characters. If this criteria doesn't match, then the sign up request is failed with the returned message. You can modify this function to be more complex and match your criteria.
- You may have noticed that the `id` is still `"email"`. This is because from SuperTokens' point of view, we will still be storing the username in the SuperTokens' user's email field. This has no side effect other than you (the developer) having to fetch the user's username using the `user.email` field (where `user` is the user object returned by SuperTokens).

## Overriding the sign up API to save the user's email
The sign up API will take in the username, password and an optional email. In order to support this, we must add a new form field for the email and add a `validate` function which checks the uniqueness and syntax of the input email.

Then we must override the sign up API to save this email against the userID of that user.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import EmailPassword from "supertokens-node/recipe/emailpassword";

async function getUserUsingEmail(email: string): Promise<string | undefined> {
    // TODO: Check your database for if the email is associated with a user
    // and return that user ID if it is.
    return undefined;
}

SuperTokens.init({
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    supertokens: {
        connectionURI: "...",
    },
    recipeList: [
        EmailPassword.init({
            signUpFeature: {
                formFields: [{
                    id: "email",
                    validate: async (value) => {
                        if (typeof value !== "string") {
                            return "Please provide a string input."
                        }
                        if (value.length < 3) {
                            return "Usernames must be at least 3 characters long."
                        }
                        if (!value.match(/^[a-z0-9_-]+$/)) {
                            return "Username must contain only alphanumeric, underscore or hyphen characters."
                        }
                    }
                }, {
                    // highlight-start
                    id: "actualEmail",
                    validate: async (value) => {
                        if (
                            value.match(
                                /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
                            ) === null
                        ) {
                            return "Email is invalid";
                        }

                        if ((await getUserUsingEmail(value)) !== undefined) {
                            return "Email already in use. Please sign in, or use another email"
                        }
                    }
                    // highlight-end
                }]
            }
        })
    ]
});
```

</TabItem>
<TabItem value="go">

```go
TODO
```

</TabItem>
<TabItem value="python">

```python
TODO
```

</TabItem>
</BackendSDKTabs>

- We call the new form field `actualEmail`. You can change this if you like, but whatever you set it to, should be used by the frontend as well when calling the sign up API.
- You need to implement the `getUserUsingEmail` function to check your database for if there already exists a user with that email. SuperTokens will not have this information since it will be storing the username of the user instead of their email. That being said, you could use the [usermetadata recipe](../usermetadata/about) to store this where the input ID to the recipe is the email and the associated JSON contains the userId of the user.

Now we must override the sign up API to save the `actualEmail` form field value against the user ID.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import EmailPassword from "supertokens-node/recipe/emailpassword";

async function getUserUsingEmail(email: string): Promise<string | undefined> {
    // TODO: Check your database for if the email is associated with a user
    // and return that user ID if it is.
    return undefined;
}

async function saveEmailForUser(email: string, userId: string) {
    // TODO: Save email and userId mapping
}

SuperTokens.init({
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    supertokens: {
        connectionURI: "...",
    },
    recipeList: [
        EmailPassword.init({
            // highlight-start
            override: {
                apis: (original) => {
                    return {
                        ...original,
                        signUpPOST: async function (input) {
                            let response = await original.signUpPOST!(input);
                            if (response.status === "OK") {
                                // sign up successful
                                let actualEmail = input.formFields.find(i => i.value === "actualEmail")!.value;
                                if (actualEmail === "") {
                                    // User did not provide an email.
                                    // This is possible since we set optional: true
                                    // in the formField config 
                                } else {
                                    await saveEmailForUser(actualEmail, response.user.id)
                                }
                            }
                            return response
                        }
                    }
                }
            },
            // highlight-end
            signUpFeature: {
                formFields: [ /* ... from previous code snippet ... */]
            }
        })
    ]
});
```

</TabItem>
<TabItem value="go">

```go
TODO
```

</TabItem>
<TabItem value="python">

```python
TODO
```

</TabItem>
</BackendSDKTabs>

- We first call the `original.signUpPOST` function which will sign up the user with username and password login. It will also enforce uniqueness of the username - if not unique, it will return an appropriate reply to the frontend.
- If the sign up was successful, we will exptract the `"actualEmail"` form field from the input. If the value is `""`, it means that the user did not specify their email. Else we will save the userId and email mapping using the `saveEmailForUser` function.
- `saveEmailForUser` is a function that you must implement. You can either store the mapping in your own database, or use the usermetadata recipe as previously stated.

## Overriding the sign in API to accept email or username
We want the user to be able to sign in using their email or username along with their password. In order to implement this, we must override the sign in recipe function as follows:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import EmailPassword from "supertokens-node/recipe/emailpassword";

async function getUserUsingEmail(email: string): Promise<string | undefined> {
    // TODO: Check your database for if the email is associated with a user
    // and return that user ID if it is.
    return undefined;
}

async function saveEmailForUser(email: string, userId: string) {
    // TODO: Save email and userId mapping
}

// highlight-start
function isInputEmail(input: string): boolean {
    return input.match(
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
    ) !== null;
}
// highlight-end

SuperTokens.init({
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    supertokens: {
        connectionURI: "...",
    },
    recipeList: [
        EmailPassword.init({
            override: {
                // highlight-start
                functions: (original) => {
                    return {
                        ...original,
                        signIn: async function (input) {
                            if (isInputEmail(input.email)) {
                                let userId = await getUserUsingEmail(input.email);
                                if (userId !== undefined) {
                                    let superTokensUser = await EmailPassword.getUserById(userId);
                                    if (superTokensUser !== undefined) {
                                        input.email = superTokensUser.email
                                    }
                                }
                            }
                            return original.signIn(input);
                        }
                    }
                },
                // highlight-end
                apis: (original) => {
                    return {
                        ...original,
                        // override from previous code snippet
                    }
                }
            },
            signUpFeature: {
                formFields: [ /* ... from previous code snippet ... */]
            }
        })
    ]
});
```

</TabItem>
<TabItem value="go">

```go
TODO
```

</TabItem>
<TabItem value="python">

```python
TODO
```

</TabItem>
</BackendSDKTabs>

- Notice that this time, we provided the override function to `override.function` config and not the `override.apis` config. This is because this function is called not only duringt the sign in API, but also if you call the `Emailpassword.signIn` function manually in your own APIs.
- First we check if the input is a valid email - using a regex. If it's not, then we call the `original.signIn` function which will try to do a username + password login.
- If the input is an email, then we fetch the userID of that email using the previously implemented `getUserUsingEmail` function. If that cannot find a user mapping, then we let the code fallthrough to `original.signIn`.
- If a user ID was found, then we query SuperTokens using `EmailPassword.getUserById` to get the SuperTokens user object. Freom there, we change the `input.email` to the username of the user, which is stored in `superTokensUser.email`. After modifying the input, we let the `original.signIn` function run which will attempt a username and password login.

## Overriding the password reset link API to accept username or email
TODO

## Changing the frontend's email validator function
- For sign up / in
- For password reset

## Adding an optional email field in the sign up form
TODO

## Changing the form labels on the frontend to replace "Email" with "Username" 
TODO