---
sidebar_position: 1
title: Protecting API and website routes
hide_title: true
---

<!-- COPY DOCS -->
<!-- ./userroles/protecting-routes.mdx -->

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import NodeJSFrameworkSubTabs from "/src/components/tabs/NodeJSFrameworkSubTabs";
import GoFrameworkSubTabs from "/src/components/tabs/GoFrameworkSubTabs"
import PythonFrameworkSubTabs from "/src/components/tabs/PythonFrameworkSubTabs";
import TabItem from '@theme/TabItem';
import FrontendSDKTabs from "/src/components/tabs/FrontendSDKTabs"
import FrontendReactContextSubTabs from "/src/components/tabs/FrontendReactContextSubTabs"
import NpmOrScriptTabs from "/src/components/tabs/NpmOrScriptTabs"

# Protecting API and website routes

## Protecting API routes

In your API routes you:
1. Verify that a session exists
2. Validate that the roles/permissions saved in the access token payload have the appropriate value

<BackendSDKTabs>
<TabItem value="nodejs">
<NodeJSFrameworkSubTabs>
<TabItem value="express">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import express from "express";
import { SessionRequest } from "supertokens-node/framework/express";
import UserRoles from "supertokens-node/recipe/userroles";

let app = express();

app.post(
    "/update-blog",
    verifySession({
        overrideGlobalClaimValidators: async (globalValidators) => [
            ...globalValidators,
            UserRoles.UserRoleClaim.validators.includes("admin"),
            // UserRoles.PermissionClaim.validators.includes("edit")
        ],
    }),
    async (req: SessionRequest, res) => {
        // All validator checks have passed and the user is an admin.
    }
);
```
</TabItem>
<TabItem value="hapi">

```tsx
import Hapi from "@hapi/hapi";
import { verifySession } from "supertokens-node/recipe/session/framework/hapi";
import {SessionRequest} from "supertokens-node/framework/hapi";
import UserRoles from "supertokens-node/recipe/userroles";

let server = Hapi.server({ port: 8000 });

server.route({
    path: "/update-blog",
    method: "post",
    options: {
        pre: [
            {
                method: verifySession({
                    overrideGlobalClaimValidators: async (globalValidators) => [
                        ...globalValidators,
                        UserRoles.UserRoleClaim.validators.includes("admin"),
                        // UserRoles.PermissionClaim.validators.includes("edit")
                    ],
                }),
            },
        ],
    },
    handler: async (req: SessionRequest, res) => {
        // All validator checks have passed and the user is an admin.
    }
})
```
</TabItem>
<TabItem value="fastify">

```tsx
import Fastify from "fastify";
import { verifySession } from "supertokens-node/recipe/session/framework/fastify";
import { SessionRequest } from "supertokens-node/framework/fastify";
import UserRoles from "supertokens-node/recipe/userroles";

let fastify = Fastify();

fastify.post("/update-blog", {
    preHandler: verifySession({
        overrideGlobalClaimValidators: async (globalValidators) => [
            ...globalValidators,
            UserRoles.UserRoleClaim.validators.includes("admin"),
            // UserRoles.PermissionClaim.validators.includes("edit")
        ],
    }),
}, async (req: SessionRequest, res) => {
    // All validator checks have passed and the user is an admin.
});
```

</TabItem>
<TabItem value="awsLambda">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/awsLambda";
import { SessionEvent } from "supertokens-node/framework/awsLambda";
import UserRoles from "supertokens-node/recipe/userroles";

async function updateBlog(awsEvent: SessionEvent) {
    // All validator checks have passed and the user is an admin.
};

exports.handler = verifySession(updateBlog, {
    overrideGlobalClaimValidators: async (globalValidators) => ([
        ...globalValidators, 
        UserRoles.UserRoleClaim.validators.includes("admin"),
        // UserRoles.PermissionClaim.validators.includes("edit")
    ])
});
```

</TabItem>
<TabItem value="koa">

```tsx
import KoaRouter from "koa-router";
import { verifySession } from "supertokens-node/recipe/session/framework/koa";
import {SessionContext} from "supertokens-node/framework/koa";
import UserRoles from "supertokens-node/recipe/userroles";

let router = new KoaRouter();

router.post("/update-blog", verifySession({
        overrideGlobalClaimValidators: async (globalValidators) => ([
            ...globalValidators, 
            UserRoles.UserRoleClaim.validators.includes("admin"),
            // UserRoles.PermissionClaim.validators.includes("edit")
        ])
    }), async (ctx: SessionContext, next) => {
    // All validator checks have passed and the user is an admin.
});
```

</TabItem>
<TabItem value="loopback">

```tsx
import { inject, intercept } from "@loopback/core";
import { RestBindings, MiddlewareContext, post, response } from "@loopback/rest";
import { verifySession } from "supertokens-node/recipe/session/framework/loopback";
import Session from "supertokens-node/recipe/session";
import UserRoles from "supertokens-node/recipe/userroles";

class SetRole {
    constructor(@inject(RestBindings.Http.CONTEXT) private ctx: MiddlewareContext) { }
    @post("/update-blog")
    @intercept(verifySession({
        overrideGlobalClaimValidators: async (globalValidators) => ([
            ...globalValidators, 
            UserRoles.UserRoleClaim.validators.includes("admin"),
            // UserRoles.PermissionClaim.validators.includes("edit")
        ])
    }))
    @response(200)
    async handler() {
        // All validator checks have passed and the user is an admin.
    }
}
```

</TabItem>
<TabItem value="nextjs">

```tsx
import { superTokensNextWrapper } from 'supertokens-node/nextjs'
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express";
import UserRoles from "supertokens-node/recipe/userroles";

// highlight-start
export default async function setRole(req: SessionRequest, res: any) {
    await superTokensNextWrapper(
        async (next) => {
            await verifySession({
                overrideGlobalClaimValidators: async (globalValidators) => ([
                    ...globalValidators, 
                    UserRoles.UserRoleClaim.validators.includes("admin"),
                    // UserRoles.PermissionClaim.validators.includes("edit")
                ])
            })(req, res, next);
        },
        req,
        res
    )
    // All validator checks have passed and the user is an admin.
}
```

</TabItem>
<TabItem value="nestjs">

```tsx
import { Controller, Post, UseGuards, Request, Response, Session } from "@nestjs/common";
import { SessionContainer, SessionClaimValidator } from "supertokens-node/recipe/session";
// @ts-ignore
import { AuthGuard } from './auth/auth.guard';
import UserRoles from "supertokens-node/recipe/userroles";

@Controller()
export class ExampleController {
  @Post('example')
  @UseGuards(new AuthGuard({
    overrideGlobalClaimValidators: async (globalValidators: SessionClaimValidator[]) => ([
        ...globalValidators, 
        UserRoles.UserRoleClaim.validators.includes("admin"),
        // UserRoles.PermissionClaim.validators.includes("edit")
    ])
  }))
  async postExample(@Session() session: SessionContainer): Promise<boolean> {
    // All validator checks have passed and the user is an admin.
    return true;
  }
}
```
</TabItem>

</NodeJSFrameworkSubTabs>
</TabItem>
<TabItem value="go">
<GoFrameworkSubTabs>
<TabItem value="http">

```go
TODO
```

</TabItem>
<TabItem value="gin">

```go
TODO
```

</TabItem>
<TabItem value="chi">

```go
TODO
```

</TabItem>
<TabItem value="mux">

```go
TODO
```

</TabItem>
</GoFrameworkSubTabs>
</TabItem>
<TabItem value="python">

<PythonFrameworkSubTabs>
<TabItem value="fastapi">

```python
TODO
```

</TabItem>
<TabItem value="flask">

```python
TODO
```

</TabItem>
<TabItem value="django">

```python
TODO
```

</TabItem>
</PythonFrameworkSubTabs>

</TabItem>
</BackendSDKTabs>

- We add a new claim validator to the `verifySession` function which makes sure that the user has an `admin` role.
- The `globalValidators` represents other validators that apply to all API routes by default. This may include a validator that enforces that the user's email is verified (if enabled by you).
- We can also add a `PermissionClaim` validator to enforce a permission.

If you want to have more complex access control, you can either create your own validator, or you can get the roles list from the session as follows, and check the list yourself:

<BackendSDKTabs>
<TabItem value="nodejs">
<NodeJSFrameworkSubTabs>
<TabItem value="express">

```tsx
import express from "express";
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express";
import UserRoles from "supertokens-node/recipe/userroles";

let app = express();

app.post("/update-blog", verifySession(), async (req: SessionRequest, res) => {
    // highlight-next-line
    const roles = await req.session!.getClaimValue(UserRoles.UserRoleClaim);
    // Check roles array for the required roles...
});
```
</TabItem>
<TabItem value="hapi">

```tsx
import Hapi from "@hapi/hapi";
import { verifySession } from "supertokens-node/recipe/session/framework/hapi";
import {SessionRequest} from "supertokens-node/framework/hapi";
import UserRoles from "supertokens-node/recipe/userroles";

let server = Hapi.server({ port: 8000 });

server.route({
    path: "/update-blog",
    method: "post",
    options: {
        pre: [
            {
                method: verifySession()
            },
        ],
    },
    handler: async (req: SessionRequest, res) => {
        // highlight-next-line
        const roles = await req.session!.getClaimValue(UserRoles.UserRoleClaim);
        // Check roles array for the required roles...
    }
})
```
</TabItem>
<TabItem value="fastify">

```tsx
import Fastify from "fastify";
import { verifySession } from "supertokens-node/recipe/session/framework/fastify";
import { SessionRequest } from "supertokens-node/framework/fastify";
import UserRoles from "supertokens-node/recipe/userroles";

let fastify = Fastify();

fastify.post("/update-blog", {
    preHandler: verifySession(),
}, async (req: SessionRequest, res) => {
    // highlight-next-line
    const roles = await req.session!.getClaimValue(UserRoles.UserRoleClaim);
    // Check roles array for the required roles...
});
```

</TabItem>
<TabItem value="awsLambda">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/awsLambda";
import { SessionEvent } from "supertokens-node/framework/awsLambda";
import UserRoles from "supertokens-node/recipe/userroles";

async function updateBlog(awsEvent: SessionEvent) {
    // highlight-next-line
    const roles = await awsEvent.session!.getClaimValue(UserRoles.UserRoleClaim);
    // Check roles array for the required roles...
};

exports.handler = verifySession(updateBlog);
```

</TabItem>
<TabItem value="koa">

```tsx
import KoaRouter from "koa-router";
import { verifySession } from "supertokens-node/recipe/session/framework/koa";
import { SessionContext } from "supertokens-node/framework/koa";
import UserRoles from "supertokens-node/recipe/userroles";

let router = new KoaRouter();

router.post("/update-blog", verifySession(), async (ctx: SessionContext, next) => {
    // highlight-next-line
    const roles = await ctx.session!.getClaimValue(UserRoles.UserRoleClaim);
    // Check roles array for the required roles...
});
```

</TabItem>
<TabItem value="loopback">

```tsx
import { inject, intercept } from "@loopback/core";
import { RestBindings, MiddlewareContext, post, response } from "@loopback/rest";
import { verifySession } from "supertokens-node/recipe/session/framework/loopback";
import Session from "supertokens-node/recipe/session";
import UserRoles from "supertokens-node/recipe/userroles";

class UpdateBlog {
    constructor(@inject(RestBindings.Http.CONTEXT) private ctx: MiddlewareContext) {}
    @post("/update-blog")
    @intercept(verifySession())
    @response(200)
    async handler() {
        // highlight-next-line
        const roles = await ((this.ctx as any).session as Session.SessionContainer).getClaimValue(UserRoles.UserRoleClaim);
        // Check roles array for the required roles...
    }
}
```

</TabItem>
<TabItem value="nextjs">

```tsx
import { superTokensNextWrapper } from 'supertokens-node/nextjs'
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express";
import UserRoles from "supertokens-node/recipe/userroles";

export default async function updateBlog(req: SessionRequest, res: any) {
    await superTokensNextWrapper(
        async (next) => {
            await verifySession()(req, res, next);
        },
        req,
        res
    )

	// highlight-next-line
    const roles = await req.session!.getClaimValue(UserRoles.UserRoleClaim);
    // Check roles array for the required roles...
}
```

</TabItem>
<TabItem value="nestjs">

```tsx
import { Controller, Post, UseGuards, Session } from "@nestjs/common";
import { SessionContainer } from "supertokens-node/recipe/session";
// @ts-ignore
import { AuthGuard } from './auth/auth.guard';
import UserRoles from "supertokens-node/recipe/userroles";

@Controller()
export class ExampleController {
  @Post('example')
  @UseGuards(AuthGuard)
  async postExample(@Session() session: SessionContainer): Promise<boolean> {
    // highlight-start
    const roles = await session.getClaimValue(UserRoles.UserRoleClaim);
    // highlight-end
    // Check roles array for the required roles...
    return true;
  }
}
```
</TabItem>
</NodeJSFrameworkSubTabs>
</TabItem>
<TabItem value="go">
<GoFrameworkSubTabs>
<TabItem value="http">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	http.ListenAndServe("SERVER ADDRESS", corsMiddleware(
		supertokens.Middleware(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
			// Handle your APIs..
			if r.URL.Path == "/update-blog" && r.Method == "POST" {
				// Calling the API with session verification
				session.VerifySession(nil, updateBlog).ServeHTTP(rw, r)
				return
			}
		}))))
}

func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(response http.ResponseWriter, r *http.Request) {
		//...
	})
}

func updateBlog(w http.ResponseWriter, r *http.Request) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(r.Context())
	userId := sessionContainer.GetUserID()

	// highlight-start
	TODO
	// highlight-end
}
```

</TabItem>
<TabItem value="gin">

```go
import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
)

func main() {
	router := gin.New()

	router.POST("/update-blog", verifySession(nil), updateBlog)
}

// Wrap session.VerifySession to work with Gin
func verifySession(options *sessmodels.VerifySessionOptions) gin.HandlerFunc {
	return func(c *gin.Context) {
		session.VerifySession(options, func(rw http.ResponseWriter, r *http.Request) {
			c.Request = c.Request.WithContext(r.Context())
			c.Next()
		})(c.Writer, c.Request)
		// we call Abort so that the next handler in the chain is not called, unless we call Next explicitly
		c.Abort()
	}
}

// This is the API handler.
func updateBlog(c *gin.Context) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(c.Request.Context())
	userId := sessionContainer.GetUserID()

	// highlight-start
	TODO
	// highlight-end
}
```

</TabItem>
<TabItem value="chi">

```go
import (
	"net/http"

	"github.com/go-chi/chi"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
)

func main() {
	r := chi.NewRouter()

	r.Post("/update-blog", session.VerifySession(nil, updateBlog))
}

// This is the API handler.
func updateBlog(w http.ResponseWriter, r *http.Request) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(r.Context())
	userId := sessionContainer.GetUserID()

	// highlight-start
	TODO
	// highlight-end
}
```

</TabItem>
<TabItem value="mux">

```go
import (
	"net/http"

	"github.com/gorilla/mux"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
)

func main() {
	router := mux.NewRouter()

	router.HandleFunc("/update-blog",
		session.VerifySession(nil, updateBlog)).Methods(http.MethodPost)
}

// This is the API handler.
func updateBlog(w http.ResponseWriter, r *http.Request) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(r.Context())
	userId := sessionContainer.GetUserID()

	// highlight-start
	TODO
	// highlight-end
}
```

</TabItem>
</GoFrameworkSubTabs>
</TabItem>
<TabItem value="python">

<PythonFrameworkSubTabs>
<TabItem value="fastapi">

```python
from fastapi import Depends
from supertokens_python.recipe.session.framework.fastapi import verify_session
from supertokens_python.recipe.session import SessionContainer
from supertokens_python.recipe.userroles.asyncio import get_roles_for_user

@app.post('/update-blog') # type: ignore
async def update_blog_api(session: SessionContainer = Depends(verify_session())):
    user_id = session.get_user_id()
    # highlight-next-line
    TODO

```

</TabItem>
<TabItem value="flask">

```python
from flask import Flask, g
from supertokens_python.recipe.session.framework.flask import verify_session
from supertokens_python.recipe.session import SessionContainer
from supertokens_python.recipe.userroles.syncio import get_roles_for_user

app = Flask(__name__)

@app.route('/update-blog', methods=['POST']) # type: ignore
@verify_session()
def set_role_api():
    session: SessionContainer = g.supertokens # type: ignore
    user_id = session.get_user_id()
    # highlight-next-line
    TODO

```

</TabItem>
<TabItem value="django">

```python
from django.http import HttpRequest
from supertokens_python.recipe.session.framework.django.asyncio import verify_session
from supertokens_python.recipe.session import SessionContainer
from supertokens_python.recipe.userroles.asyncio import get_roles_for_user

@verify_session()
async def get_user_info_api(request: HttpRequest):
    session: SessionContainer = request.supertokens # type: ignore
    user_id = session.get_user_id()

    # highlight-next-line
    TODO

```

</TabItem>
</PythonFrameworkSubTabs>


</TabItem>
</BackendSDKTabs>

## Protecting website routes

On your frontend:

1. Verify that a session exists
2. Use the roles / permissions claim validators to enforce certain roles and permissions

<FrontendSDKTabs>
<TabItem value="reactjs">

```tsx
import React from "react";
import { SessionAuth } from 'supertokens-auth-react/recipe/session';
import { UserRoleClaim, /*PermissionClaim*/ } from 'supertokens-auth-react/recipe/userroles';
// @ts-ignore
import ProtectedComponent from "./dashboard";

const ProtectedRoute = () => {
    return (
        <SessionAuth
            overrideGlobalClaimValidators={(globalValidators) => 
                [...globalValidators,
                    UserRoleClaim.validators.includes("admin"),
                 /* PermissionClaim.validators.includes("modify") */
                ]
            }
        >
            {/* ProtectedComponent will only render if the user has the admin role */}
            <ProtectedComponent />
        </SessionAuth>
    );
}
```

</TabItem>

<TabItem value="vanillajs">

<NpmOrScriptTabs>
<TabItem value="npm">

```tsx
import Session from "supertokens-web-js/recipe/session";
import { UserRoleClaim, /*PermissionClaim*/ } from "supertokens-web-js/recipe/userroles";

async function shouldLoadRoute(): Promise<boolean> {
    if (await Session.doesSessionExist()) {

        // highlight-start
        let validationErrors = await Session.validateClaims({
            overrideGlobalClaimValidators: (globalValidators) =>
                [...globalValidators,
                    UserRoleClaim.validators.includes("admin"),
                 /* PermissionClaim.validators.includes("modify") */
                ]
        });
        // highlight-end

        if (validationErrors.length === 0) {
            // user is an admin
            return true;
        }
    }
    // either a session does not exist, or one of the validators failed.
    // so we do not allow access to this page.
    return false
}
```

</TabItem>
<TabItem value="script">

```tsx
import supertokensSession from "supertokens-web-js-script/recipe/session";
import supertokensUserRoles from "supertokens-web-js-script/recipe/userroles";
async function shouldLoadRoute(): Promise<boolean> {
    if (await supertokensSession.doesSessionExist()) {

        // highlight-start
        let validationErrors = await supertokensSession.validateClaims({
            overrideGlobalClaimValidators: (globalValidators) =>
                [...globalValidators,
                    supertokensUserRoles.UserRoleClaim.validators.includes("admin"),
                 /* supertokensUserRoles.PermissionClaim.validators.includes("modify") */
                ]
        });
        // highlight-end

        if (validationErrors.length === 0) {
            // user is an admin
            return true;
        }
    }
    // either a session does not exist, or one of the validators failed.
    // so we do not allow access to this page.
    return false
}
```

</TabItem>
</NpmOrScriptTabs>

</TabItem>
<TabItem value="react-native">

```tsx
import SuperTokens from 'supertokens-react-native';

async function getRole() {
    if (await SuperTokens.doesSessionExist()) {

        // highlight-start
        let roles: string[] = (await SuperTokens.getAccessTokenPayloadSecurely())["st-role"].v;

        if (roles.includes("admin")) {
            // TODO..
        } else {
            // TODO..
        }
        // highlight-end
    }
}
```

</TabItem>

<TabItem value="angular">

~COPY-TABS=npm,vanillajs

</TabItem>

</FrontendSDKTabs>
