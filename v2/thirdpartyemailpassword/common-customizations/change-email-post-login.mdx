---
id: change-email-post-login
title: Allow users to change their email
hide_title: true
---

<!-- COPY DOCS -->
<!-- ./thirdpartyemailpassword/common-customizations/change-email-post-login.mdx -->

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import BackendSDKCasing from "/src/components/BackendSDKCasing"
import TabItem from '@theme/TabItem';

# Allow users to change their email 

:::caution
SuperTokens does not provide the UI for users to update their email, you will need to create the UI and setup a route on your backend to have this functionality.
:::

In this section we will go over how you can create a route on your backend which can update a user's email. Calling this route will check if the new email is valid, not already in use and update the user's profile with the new password. There are two types of flows here:

## Flow 1: Changing email without requiring email verification.

### Step 1: Creating the `/change-email` route
- You will need to create a route on your backend which is protected by the session verification middleware, this will ensure that only a authenticated user can access the protected route.
- To learn more about how to use the session verification middleware for other frameworks click [here](verify-session)

<BackendSDKTabs>

<TabItem value="nodejs">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";

let app = express();

// highlight-start
app.post("/change-email", verifySession(), async (req: SessionRequest, res: express.Response) => {
    // TODO: see next steps
})

// highlight-end
```
</TabItem>

<TabItem value="go">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
)

// highlight-start
// the following example uses net/http
func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changeEmailAPI).ServeHTTP(rw, r)
	})
}

func changeEmailAPI(w http.ResponseWriter, r *http.Request) {
	// TODO: see next steps
}

// highlight-end
```

</TabItem>


<TabItem value="python">

```python
# the following example uses flask
from supertokens_python.recipe.session.framework.flask import verify_session
from flask import Flask

app = Flask(__name__)

# highlight-start
@app.route('/change-email', methods=['POST']) # type: ignore
@verify_session()
def change_password():
    pass # TODO: see next steps
# highlight-end
```

</TabItem>

</BackendSDKTabs>

### Step 2: Validate and update the user's email

- Validate the input email.
- Check if the account you are trying to update is a social account.
- Check if the input email is associated with an account.
- Update the input email.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
// the following example uses express
import ^{recipeNameCapitalLetters} from "supertokens-node/recipe/^{codeImportRecipeName}";
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";

let app = express();

app.post("/change-email", verifySession(), async (req: SessionRequest, res: express.Response) => {

    // highlight-start
    let session = req.session!;
    let email = req.body.email;

    // Validate the input email
    if (!isValidEmail(email)) {
        // TODO: handle invalid email error
        return 
    }

    // Check that the account to be updated is not a social account
    {
        let userId = session?.getUserId();
        let userAccount = await ThirdPartyEmailPassword.getUserById(userId!);
        if (userAccount!.thirdParty !== undefined) {
            // TODO: handle error, cannot update email for third party users.
            return 
        }
    }

    // Check if the new email is already associated with another user.
    // If it is, then we throw an error. If it's already associated with this user,
    // then we return a success response with an appropriate message.
    let existingUser = await EmailPassword.getUserByEmail(email);
    if (existingUser !== undefined) {
        if (existingUser.id === session.getUserId()) {
            // TODO: send successful responses that email already belongs to this account
            return 
        } else {
            // TODO: handle error that email exists with another account.
            return
        }
    }
    
    // Update the email
    let resp = await EmailPassword.updateEmailOrPassword({
        userId: session.getUserId(),
        email: email,
    });

    if (resp.status === "OK") {
        // TODO: send successfully updated email response
        return 
    }
    if (resp.status === "EMAIL_ALREADY_EXISTS_ERROR") {
        // Technically it should never come here cause we have
        // checked for this above already, but just in case (some sort of race condition).
        // TODO: handle error that email exists with another account.
        return
    }
    throw new Error("Should never come here");
    // highlight-end

})

```


</TabItem>

<TabItem value="go">

```go
import (
	"encoding/json"
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/^{codeImportRecipeName}"
)

func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changePasswordAPI).ServeHTTP(rw, r)
	})
}

type RequestBody struct {
	OldPassword string
	NewPassword string
}

func changePasswordAPI(w http.ResponseWriter, r *http.Request) {


}
```

</TabItem>

<TabItem value="python">

```python
from supertokens_python.recipe.session.framework.flask import verify_session
from supertokens_python.recipe.session import SessionContainer
from supertokens_python.recipe.^{rid}.syncio import get_user_by_id, ^{pythonSignIn}, update_email_or_password
from supertokens_python.recipe.^{rid}.interfaces import ^{codeSignInWrongCredentialsErrorPythonType}, UpdateEmailOrPasswordPasswordPolicyViolationError
from flask import g

@app.route('/change-password', methods=['POST']) # type: ignore
@verify_session()
def change_password():


```

</TabItem>
</BackendSDKTabs>

## Flow 2: Changing email after the new email is verified. 

### Step 2: Validate and update the user's email

- Validate the input email
- Check if the input email is associated with an account.
- Check if the input email is already verified.
- If the email is not verified, create and send the verification email.
- If the email is verified, update the account with the new email.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
// the following example uses express
import ^{recipeNameCapitalLetters} from "supertokens-node/recipe/^{codeImportRecipeName}";
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";

let app = express();

app.post("/change-password", verifySession(), async (req: SessionRequest, res: express.Response) => {

    // highlight-start
    let session = req.session!;
    let email = req.body.email;

    // Check if the input email
    if (!isValidEmail(email)) {
        return res.status(400).send("Email is invalid");
    }

    // This resets the state of the session related to the email update.
    // We do this here cause there are many code flow branches below which result in
    // not triggering the email verification flow, in which we want to do this.
    // So instead of duplicating this code below, we do it once on top. If the
    // toUpdateEmail doesn't exist in the session, this is a no-op.
    await session.mergeIntoAccessTokenPayload({
        toUpdateEmail: null,
    });

    // First we check if the new email is already associated with another user.
    // If it is, then we throw an error. If it's already associated with this user,
    // then we return a success response with an appropriate message.
    let existingUser = await EmailPassword.getUserByEmail(email);
    if (existingUser !== undefined) {
        if (existingUser.id === session.getUserId()) {
            return res.status(200).send("Email already belongs to this account");
        } else {
            return res.status(400).send("Email already exists with another user");
        }
    }

    // Then, we check if the email is verified for this user ID or not.
    // It is important to understand that SuperTokens stores email verification
    // status based on the user ID AND the email, and not just the email.
    let isVerified = await EmailVerification.isEmailVerified(session.getUserId(), email);

    if (!isVerified) {
        // Now we create and send the email verification link to the user for the new email.
        let tokenInfo = await EmailVerification.createEmailVerificationToken(session.getUserId(), email);

        if (tokenInfo.status === "OK") {
            let link = "http://localhost:3000/auth/verify-email?token=" + tokenInfo.token;

            await EmailVerification.sendEmail({
                emailVerifyLink: link,
                type: "EMAIL_VERIFICATION",
                user: {
                    id: session.getUserId(),
                    email: email,
                },
            });

            return res.status(200).send("Email verification email sent");
        }
        // else case is that the email is already verified (which can happen cause
        // of some race condition). So we continue below..
    }

    // Since the email is verified, we try and do an update
    let resp = await EmailPassword.updateEmailOrPassword({
        userId: session.getUserId(),
        email: email,
    });

    if (resp.status === "OK") {
        return res.status(200).send("Successfully updated email");
    }
    if (resp.status === "EMAIL_ALREADY_EXISTS_ERROR") {
        // Technically it should never come here cause we have
        // checked for this above already, but just in case (some sort of race condition).
        return res.status(400).send("Email already exists with another user");
    }
    throw new Error("Should never come here");
    // highlight-end

})

```


</TabItem>

<TabItem value="go">

```go
import (
	"encoding/json"
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/^{codeImportRecipeName}"
)

func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changePasswordAPI).ServeHTTP(rw, r)
	})
}

type RequestBody struct {
	OldPassword string
	NewPassword string
}

func changePasswordAPI(w http.ResponseWriter, r *http.Request) {

	// retrieve the session object as shown below
	sessionContainer := session.GetSessionFromRequestContext(r.Context())

	// retrive the old password from the request body
	var requestBody RequestBody
	err := json.NewDecoder(r.Body).Decode(&requestBody)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// get the userId from the session
	userID := sessionContainer.GetUserID()

	// get the signed in user's email from the getUserById function
	userInfo, err := ^{rid}.^{goGetUserById}(userID)
	if err != nil {
		// TODO: Handle error
		return
	}

	// call signin to check that the input is correct
	isPasswordValid, err := ^{rid}.^{goSignIn}(userInfo.Email, requestBody.OldPassword)
	if err != nil {
		// TODO: Handle error
		return
	}

	// highlight-start
	if isPasswordValid.OK != nil {
		// TODO: Handle error
		return
	}

	updateResponse, err := ^{rid}.UpdateEmailOrPassword(userID, &userInfo.Email, &requestBody.NewPassword, nil)
	if err != nil {
		// TODO: Handle error
		return
	}

	if updateResponse.PasswordPolicyViolatedError != nil {
		// This error is returned if the new password doesn't match the defined password policy
		// TODO: Handle error
		return
	}
	// TODO: send successful password update response
	// highlight-end

}
```

</TabItem>

<TabItem value="python">

```python
from supertokens_python.recipe.session.framework.flask import verify_session
from supertokens_python.recipe.session import SessionContainer
from supertokens_python.recipe.^{rid}.syncio import get_user_by_id, ^{pythonSignIn}, update_email_or_password
from supertokens_python.recipe.^{rid}.interfaces import ^{codeSignInWrongCredentialsErrorPythonType}, UpdateEmailOrPasswordPasswordPolicyViolationError
from flask import g

@app.route('/change-password', methods=['POST']) # type: ignore
@verify_session()
def change_password():

    # highlight-start
    session: SessionContainer = g.supertokens # type: ignore
    
    # get the userId from the session object
    user_id = session.get_user_id()

    # get the signed in user's email from the getUserById function
    users_info = get_user_by_id(user_id)

    if users_info is None:
        raise Exception("Should never come here")

    # call signin to check that the input password is correct
    isPasswordValid = ^{pythonSignIn}(users_info.email, request.json["oldPassword"]) # type: ignore

    if isinstance(isPasswordValid, ^{codeSignInWrongCredentialsErrorPythonType}):
        # TODO: handle incorrect password error
        return
    
    # update the users password
    update_response = update_email_or_password(user_id, password=request.json["newPassword"]) # type: ignore

    if isinstance(update_response, UpdateEmailOrPasswordPasswordPolicyViolationError):
        # TODO: handle password policy violation error
        return

    # TODO: send successful password update response
    # highlight-end


```

</TabItem>
</BackendSDKTabs>