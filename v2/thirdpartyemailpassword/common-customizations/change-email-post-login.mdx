---
id: change-email-post-login
title: Allow users to change their email
hide_title: true
---

<!-- COPY DOCS -->
<!-- ./thirdpartyemailpassword/common-customizations/change-email-post-login.mdx -->

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import BackendSDKCasing from "/src/components/BackendSDKCasing"
import TabItem from '@theme/TabItem';

# Allow users to change their email 

:::caution
SuperTokens does not provide the UI for users to update their email, you will need to create the UI and setup a route on your backend to have this functionality.
:::

In this section we will go over how you can create a route on your backend which can update a user's email. Calling this route will check if the new email is valid and not already in use and proceed to update the user's account with the new email. There are two types of flows here:

## Flow 1: Update email without verifying the new email.

In this flow a user is allowed to update their accounts email without verifying the new email id.

### Step 1: Creating the `/change-email` route
- You will need to create a route on your backend which is protected by the session verification middleware, this will ensure that only a authenticated user can access the protected route.
- To learn more about how to use the session verification middleware for other frameworks click [here](verify-session)

<BackendSDKTabs>

<TabItem value="nodejs">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";

let app = express();

// highlight-start
app.post("/change-email", verifySession(), async (req: SessionRequest, res: express.Response) => {
    // TODO: see next steps
})

// highlight-end
```
</TabItem>

<TabItem value="go">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
)

// highlight-start
// the following example uses net/http
func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changeEmailAPI).ServeHTTP(rw, r)
	})
}

func changeEmailAPI(w http.ResponseWriter, r *http.Request) {
	// TODO: see next steps
}

// highlight-end
```

</TabItem>


<TabItem value="python">

```python
# the following example uses flask
from supertokens_python.recipe.session.framework.flask import verify_session
from flask import Flask

app = Flask(__name__)

# highlight-start
@app.route('/change-email', methods=['POST']) # type: ignore
@verify_session()
def change_password():
    pass # TODO: see next steps
# highlight-end
```

</TabItem>

</BackendSDKTabs>

### Step 2: Validate the new email and update the account

- Validate the input email.
- Check if the account you are trying to update is a social account.
- Check if the input email is associated with an account.
- Update the input email.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
// the following example uses express
import ^{recipeNameCapitalLetters} from "supertokens-node/recipe/^{codeImportRecipeName}";
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";

let app = express();

app.post("/change-email", verifySession(), async (req: SessionRequest, res: express.Response) => {

    // highlight-start
    let session = req.session!;
    let email = req.body.email;

    // Validate the input email
    if (!isValidEmail(email)) {
        // TODO: handle invalid email error
        return 
    }

    // Check that the account to be updated is not a social account
    {
        let userId = session?.getUserId();
        let userAccount = await ThirdPartyEmailPassword.getUserById(userId!);
        if (userAccount!.thirdParty !== undefined) {
            // TODO: handle error, cannot update email for third party users.
            return 
        }
    }

    // Check if the new email is already associated with another email-password user.
    // If it is, then we throw an error. If it's already associated with this user,
    // then we return a success response with an appropriate message.
    let existingUsers = await ThirdPartyEmailPassword.getUsersByEmail(email);

    if (existingUsers.length != 0) {
        for (let i = 0; i < existingUsers.length; i++) {
            if (existingUsers[i].id === session.getUserId()) {
                // TODO: send successful responses that email already belongs to this account
                return
            }

            if (existingUsers[i].thirdParty === undefined) {
                // TODO: handle error that email exists with another account.
                return
            }
        }
    }
    
    // Update the email
    let resp = await ThirdPartyEmailPassword.updateEmailOrPassword({
        userId: session.getUserId(),
        email: email,
    });

    if (resp.status === "OK") {
        // TODO: send successfully updated email response
        return 
    }
    if (resp.status === "EMAIL_ALREADY_EXISTS_ERROR") {
        // Technically it should never come here cause we have
        // checked for this above already, but just in case (some sort of race condition).
        // TODO: handle error that email exists with another account.
        return
    }
    throw new Error("Should never come here");
    // highlight-end

})

function isValidEmail(email: string) {
    let regexp = new RegExp(
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
    );
    return regexp.test(email);
}

```


</TabItem>

<TabItem value="go">

```go
import (
	"encoding/json"
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/^{codeImportRecipeName}"
)

func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changePasswordAPI).ServeHTTP(rw, r)
	})
}

type RequestBody struct {
	OldPassword string
	NewPassword string
}

func changePasswordAPI(w http.ResponseWriter, r *http.Request) {


}
```

</TabItem>

<TabItem value="python">

```python
from supertokens_python.recipe.session.framework.flask import verify_session
from supertokens_python.recipe.session import SessionContainer
from supertokens_python.recipe.^{rid}.syncio import get_user_by_id, ^{pythonSignIn}, update_email_or_password
from supertokens_python.recipe.^{rid}.interfaces import ^{codeSignInWrongCredentialsErrorPythonType}, UpdateEmailOrPasswordPasswordPolicyViolationError
from flask import g

@app.route('/change-password', methods=['POST']) # type: ignore
@verify_session()
def change_password():


```

</TabItem>
</BackendSDKTabs>

## Flow 2: Updating email after verifying the new email. 

In this flow the user's account is updated once they have verified the new email.

### Step 1: Creating the `/change-email` route
- You will need to create a route on your backend which is protected by the session verification middleware, this will ensure that only a authenticated user can access the protected route.
- To learn more about how to use the session verification middleware for other frameworks click [here](verify-session)

<BackendSDKTabs>

<TabItem value="nodejs">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";

let app = express();

// highlight-start
app.post("/change-email", verifySession(), async (req: SessionRequest, res: express.Response) => {
    // TODO: see next steps
})

// highlight-end
```
</TabItem>

<TabItem value="go">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
)

// highlight-start
// the following example uses net/http
func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changeEmailAPI).ServeHTTP(rw, r)
	})
}

func changeEmailAPI(w http.ResponseWriter, r *http.Request) {
	// TODO: see next steps
}

// highlight-end
```

</TabItem>


<TabItem value="python">

```python
# the following example uses flask
from supertokens_python.recipe.session.framework.flask import verify_session
from flask import Flask

app = Flask(__name__)

# highlight-start
@app.route('/change-email', methods=['POST']) # type: ignore
@verify_session()
def change_password():
    pass # TODO: see next steps
# highlight-end
```

</TabItem>

</BackendSDKTabs>

### Step 2: Validate the email and initiate the email verification flow

- Validate the input email
- Check that the user's account is not a social account.
- Check if the input email is associated with an account.
- Check if the input email is already verified.
- If the email is **NOT** verified, create and send the verification email.
- If the email is verified, update the account with the new email.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
// the following example uses express
import ^{recipeNameCapitalLetters} from "supertokens-node/recipe/^{codeImportRecipeName}";
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";

let app = express();

app.post("/change-password", verifySession(), async (req: SessionRequest, res: express.Response) => {

    // highlight-start
    let session = req.session!;
    let email = req.body.email;

    // Check if the input email
    if (!isValidEmail(email)) {
        return res.status(400).send("Email is invalid");
    }

    // Check if the user's account is not a third party account
    {
        let sessionId = session?.getUserId();
        let userAccount = await ThirdPartyEmailPassword.getUserById(sessionId!);
        if (userAccount!.thirdParty !== undefined) {
            // TODO handle error, cannot update password for third party users.
            return
        }
    }

    // First we check if the new email is already associated with another email-password user.
    // If it is, then we throw an error. If it's already associated with this user,
    // then we return a success response with an appropriate message.
    let existingUsers = await ThirdPartyEmailPassword.getUsersByEmail(email);

    if (existingUsers.length != 0) {
        for (let i = 0; i < existingUsers.length; i++) {
            if (existingUsers[i].id === session.getUserId()) {
                return res.status(200).send("Email already belongs to this account");
            }

            if (existingUsers[i].thirdParty === undefined) {
                return res.status(400).send("Email already exists with another user");
            }
        }
    }

    // Then, we check if the email is verified for this user ID or not.
    // It is important to understand that SuperTokens stores email verification
    // status based on the user ID AND the email, and not just the email.
    let isVerified = await EmailVerification.isEmailVerified(session.getUserId(), email);

    if (!isVerified) {
        // Now we create and send the email verification link to the user for the new email.
        let tokenInfo = await EmailVerification.createEmailVerificationToken(session.getUserId(), email);

        if (tokenInfo.status === "OK") {
            let link = "http://localhost:3000/auth/verify-email?token=" + tokenInfo.token;

            await EmailVerification.sendEmail({
                emailVerifyLink: link,
                type: "EMAIL_VERIFICATION",
                user: {
                    id: session.getUserId(),
                    email: email,
                },
            });

            return res.status(200).send("Email verification email sent");
        }
        // else case is that the email is already verified (which can happen cause
        // of some race condition). So we continue below..
    }

    // Since the email is verified, we try and do an update
    let resp = await ThirdPartyEmailPassword.updateEmailOrPassword({
        userId: session.getUserId(),
        email: email,
    });

    if (resp.status === "OK") {
        return res.status(200).send("Successfully updated email");
    }
    if (resp.status === "EMAIL_ALREADY_EXISTS_ERROR") {
        // Technically it should never come here cause we have
        // checked for this above already, but just in case (some sort of race condition).
        return res.status(400).send("Email already exists with another user");
    }
    throw new Error("Should never come here");
    // highlight-end

})

function isValidEmail(email: string) {
    let regexp = new RegExp(
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
    );
    return regexp.test(email);
}

```


</TabItem>

<TabItem value="go">

```go
import (
	"encoding/json"
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/^{codeImportRecipeName}"
)

func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changePasswordAPI).ServeHTTP(rw, r)
	})
}

type RequestBody struct {
	OldPassword string
	NewPassword string
}

func changePasswordAPI(w http.ResponseWriter, r *http.Request) {

	// retrieve the session object as shown below
	sessionContainer := session.GetSessionFromRequestContext(r.Context())

	// retrive the old password from the request body
	var requestBody RequestBody
	err := json.NewDecoder(r.Body).Decode(&requestBody)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// get the userId from the session
	userID := sessionContainer.GetUserID()

	// get the signed in user's email from the getUserById function
	userInfo, err := ^{rid}.^{goGetUserById}(userID)
	if err != nil {
		// TODO: Handle error
		return
	}

	// call signin to check that the input is correct
	isPasswordValid, err := ^{rid}.^{goSignIn}(userInfo.Email, requestBody.OldPassword)
	if err != nil {
		// TODO: Handle error
		return
	}

	// highlight-start
	if isPasswordValid.OK != nil {
		// TODO: Handle error
		return
	}

	updateResponse, err := ^{rid}.UpdateEmailOrPassword(userID, &userInfo.Email, &requestBody.NewPassword, nil)
	if err != nil {
		// TODO: Handle error
		return
	}

	if updateResponse.PasswordPolicyViolatedError != nil {
		// This error is returned if the new password doesn't match the defined password policy
		// TODO: Handle error
		return
	}
	// TODO: send successful password update response
	// highlight-end

}
```

</TabItem>

<TabItem value="python">

```python
from supertokens_python.recipe.session.framework.flask import verify_session
from supertokens_python.recipe.session import SessionContainer
from supertokens_python.recipe.^{rid}.syncio import get_user_by_id, ^{pythonSignIn}, update_email_or_password
from supertokens_python.recipe.^{rid}.interfaces import ^{codeSignInWrongCredentialsErrorPythonType}, UpdateEmailOrPasswordPasswordPolicyViolationError
from flask import g

@app.route('/change-password', methods=['POST']) # type: ignore
@verify_session()
def change_password():

    # highlight-start
    session: SessionContainer = g.supertokens # type: ignore
    
    # get the userId from the session object
    user_id = session.get_user_id()

    # get the signed in user's email from the getUserById function
    users_info = get_user_by_id(user_id)

    if users_info is None:
        raise Exception("Should never come here")

    # call signin to check that the input password is correct
    isPasswordValid = ^{pythonSignIn}(users_info.email, request.json["oldPassword"]) # type: ignore

    if isinstance(isPasswordValid, ^{codeSignInWrongCredentialsErrorPythonType}):
        # TODO: handle incorrect password error
        return
    
    # update the users password
    update_response = update_email_or_password(user_id, password=request.json["newPassword"]) # type: ignore

    if isinstance(update_response, UpdateEmailOrPasswordPasswordPolicyViolationError):
        # TODO: handle password policy violation error
        return

    # TODO: send successful password update response
    # highlight-end


```

</TabItem>
</BackendSDKTabs>


### Step 3: Override the `verifyEmailPost` API to update the user's account on successful email verification


<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import EmailVerification from "supertokens-node/recipe/emailverification";
import Session from "supertokens-node/recipe/session";

SuperTokens.init({
  appInfo: {
    apiDomain: "...",
    appName: "...",
    websiteDomain: "...",
  },
  recipeList: [
    ThirdPartyEmailPassword.init({}),
    EmailVerification.init({
        mode: "REQUIRED",
        override: {
            apis: (oI) => {
                return {
                    ...oI,
                    verifyEmailPOST: async function (input) {
                        let response = await oI.verifyEmailPOST!(input);
                        if (response.status === "OK") {
                            // This will update the email of the user to the one
                            // that was just marked as verified by the token.
                            await ThirdPartyEmailPassword.updateEmailOrPassword({
                                userId: response.user.id,
                                email: response.user.email,
                            });
                        }
                        return response;
                    },
                };
            },
        },
    }),
    Session.init(),
  ],
});
```


</TabItem>

<TabItem value="go">

```go

```

</TabItem>

<TabItem value="python">

```python

```

</TabItem>
</BackendSDKTabs>