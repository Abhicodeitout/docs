---
id: user-context
title: User Context
hide_title: true
---

<!-- COPY DOCS -->
<!-- ./thirdpartyemailpassword/advanced-customizations/user-context.mdx -->

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import TabItem from '@theme/TabItem';

# User Context

:::important
This feature is only available for SDKs versions:
- NodeJS >= `v9.0`
- Python >= `v0.5`
- GoLang >= `v0.5`
:::

## How does it work?

This is a powerful concept that allows you to pass information across recipe and / or API functions so that customisations can be made based on a specific "execution context".

For example, you may want to disable creation of a session during sign up so that the user has to login again post sign up. In order to do that, the `createNewSession` recipe function (from the Session recipe) will have to know that it's being called from the sign up API and return an empty  session (which is equal to no session). This is as opposed to it being called from the sign in API, in which it should continue with normal functionalty.

In order to achieve this, all the API interface and recipe interface functions take a parameter called `userContext` which is by default an empty object. When overriding the functions, you can add anything in this object and that information is carried onto the next set of functions being called in the API

## Example use

Let's take the example mentioned above and implement it in the context of this recipe. First, we override the sign up APIs to add information into the context indicating that it's a sign up API call:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import Session from "supertokens-node/recipe/session";

SuperTokens.init({
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    supertokens: {
        connectionURI: "...",
    },
    recipeList: [
        ThirdPartyEmailPassword.init({
            // highlight-start
            override: {
                apis: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        // override sign up using email / password 
                        emailPasswordSignUpPOST: async function (input) {
                            if (originalImplementation.emailPasswordSignUpPOST === undefined) {
                                throw new Error("Should never come here");
                            }

                            // by default, the userContext object is {},
                            // we change it to {isSignUp: true}, since this is one of the
                            // sign up API, and this will tell the createNewSession function
                            // (being called inside originalImplementation.emailPasswordSignUpPOST)
                            // to not create a new session in case userContext.isSignUp === true
                            input.userContext.isSignUp = true;
                            return originalImplementation.emailPasswordSignUpPOST(input);
                        },
                    }
                },
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        thirdPartySignInUp: async function (input) {
                            let resp = await originalImplementation.thirdPartySignInUp(input);
                            if (resp.status === "OK" && resp.createdNewUser) {
                                /*
                                 * This is called during the signInUp API for third party login,
                                 * but before calling the createNewSession function.
                                 * At the start of the API, we do not know if it will result in a 
                                 * sign in or a sign up, so we cannot override the API function.
                                 * Instead, we override the recipe function as shown here,
                                 * and then set the relevant context only if it's a new user.
                                 */
                                input.userContext.isSignUp = true;
                            }
                            return resp;
                        },
                    }
                },
            }
            // highlight-end
        })
    ]
});
```

</TabItem>
<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/emailpassword/epmodels"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword/tpepmodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	supertokens.Init(supertokens.TypeInput{
		RecipeList: []supertokens.Recipe{
			thirdpartyemailpassword.Init(&tpepmodels.TypeInput{
				// highlight-start
				Override: &tpepmodels.OverrideStruct{
					APIs: func(originalImplementation tpepmodels.APIInterface) tpepmodels.APIInterface {
						ogEmailPasswordSignUpPOST := *originalImplementation.EmailPasswordSignUpPOST

						(*originalImplementation.EmailPasswordSignUpPOST) = func(formFields []epmodels.TypeFormField, options epmodels.APIOptions, userContext supertokens.UserContext) (tpepmodels.SignUpPOSTResponse, error) {
							// by default, the userContext object is {},
							// we change it to {isSignUp: true}, since this is one of the
							// sign up API, and this will tell the CreateNewSession function
							// (being called inside ogEmailPasswordSignUpPOST)
							// to not create a new session in case userContext["isSignUp"] === true
							(*userContext)["isSignUp"] = true
							return ogEmailPasswordSignUpPOST(formFields, options, userContext)
						}

						return originalImplementation
					},
					Functions: func(originalImplementation tpepmodels.RecipeInterface) tpepmodels.RecipeInterface {
						ogThirdPartySignInUp := *originalImplementation.ThirdPartySignInUp

						(*originalImplementation.ThirdPartySignInUp) = func(thirdPartyID, thirdPartyUserID string, email tpepmodels.EmailStruct, userContext supertokens.UserContext) (tpepmodels.SignInUpResponse, error) {
							resp, err := ogThirdPartySignInUp(thirdPartyID, thirdPartyUserID, email, userContext)

							if err != nil {
								return tpepmodels.SignInUpResponse{}, err
							}

							if resp.OK != nil && resp.OK.CreatedNewUser {
								/*
								 * This is called during the signInUp API for third party login,
								 * but before calling the createNewSession function.
								 * At the start of the API, we do not know if it will result in a
								 * sign in or a sign up, so we cannot override the API function.
								 * Instead, we override the recipe function as shown here,
								 * and then set the relevant context only if it's a new user.
								 */
								(*userContext)["isSignUp"] = true
							}
							return resp, nil
						}

						return originalImplementation
					},
				},
				// highlight-end
			}),
		},
	})
}
```
</TabItem>
<TabItem value="python">

```python
TODO
```
</TabItem>
</BackendSDKTabs>


Then we consume that context in the `createNewSession` function to return an empty function in case the `userContext.isSignUp` is `true`

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import Session from "supertokens-node/recipe/session";

SuperTokens.init({
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    supertokens: {
        connectionURI: "...",
    },
    recipeList: [
        // @ts-ignore
        ThirdPartyEmailPassword.init({/* See previous step... */}),
        Session.init({
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        createNewSession: async function (input) {
                            if (input.userContext.isSignUp) {
                                /**
                                 * The execution will come here only in case
                                 * a sign up API is calling this function. This is because
                                 * only then will the input.userContext.isSignUp === true
                                 * (see above code).
                                 */
                                return {
                                    getAccessToken: () => "",
                                    getAccessTokenPayload: () => null,
                                    getExpiry: async () => -1,
                                    getHandle: () => "",
                                    getSessionData: async () => null,
                                    getTimeCreated: async () => -1,
                                    getUserId: () => "",
                                    revokeSession: async () => { },
                                    updateAccessTokenPayload: async () => { },
                                    updateSessionData: async () => { },
                                }; // this is an empty session. It won't result in a session being created for the user.
                            }
                            return originalImplementation.createNewSession(input);
                        }
                    }
                }
            }
        })
    ]
});
```

</TabItem>
<TabItem value="go">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword/tpepmodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	supertokens.Init(supertokens.TypeInput{
		RecipeList: []supertokens.Recipe{
			thirdpartyemailpassword.Init(&tpepmodels.TypeInput{ /* See previous step... */ }),
			session.Init(&sessmodels.TypeInput{
				Override: &sessmodels.OverrideStruct{
					Functions: func(originalImplementation sessmodels.RecipeInterface) sessmodels.RecipeInterface {
						ogCreateNewSession := *originalImplementation.CreateNewSession

						(*originalImplementation.CreateNewSession) = func(res http.ResponseWriter, userID string, accessTokenPayload, sessionData map[string]interface{}, userContext supertokens.UserContext) (sessmodels.SessionContainer, error) {
							_, isSignUp := (*userContext)["isSignUp"]
							if isSignUp {
								/**
								 * The execution will come here only in case
								 * a sign up API is calling this function. This is because
								 * only then will the (*userContext)["isSignUp"] === true
								 * (see above code).
								 */
								return sessmodels.SessionContainer{}, nil // this is an empty session. It won't result in a session being created for the user.
							}

							return ogCreateNewSession(res, userID, accessTokenPayload, sessionData, userContext)
						}

						return originalImplementation
					},
				},
			}),
		},
	})
}
```
</TabItem>
<TabItem value="python">

```python
TODO
```
</TabItem>
</BackendSDKTabs>

As a summary, when the sign up API is called, the initial value of `userContext` is an empty object. We change that user context to add the `isSignUp` field so that that information can be communicated to the `createNewSession` function.

When that is called, that function checks if `isSignUp === true`, and if it is, it doesn't call the original implementation, and instead, just returns an empty session. This way, we don't create a session if the user is signing up, but we do create one if the user is signing in.

Note that there are other ways of achiving this, but the above showcases how we can use user context to communicate across recipes and across API & Recipe functions.