---
id: custom-response
title: Sending custom responses
hide_title: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import NodeJSFrameworkSubTabs from "/src/components/tabs/NodeJSFrameworkSubTabs";
import PythonFrameworkSubTabs from "/src/components/tabs/PythonFrameworkSubTabs";
import TabItem from '@theme/TabItem';
import GoFrameworkSubTabs from "/src/components/tabs/GoFrameworkSubTabs"

# How to send a custom response

## Method 1) By overriding the API Interface

Let's take an example of sending a custom response for the `/auth/signup/email/exists GET` API (does email exist).

We need to first override the function for that API (`emailExistsGET`) and then use the response object in the `input` param to send a custom response.

The function signature expects an return type that has a certain shape, therefore, we must still return a valid response object from the function, but that will be ignored since you have already sent a response to the client.

<BackendSDKTabs>
<TabItem value="nodejs">

```js
ThirdPartyEmailPassword.init({
    override: {
        apis: (originalImplementation) => {
            return {
                ...originalImplementation,
                emailExistsGET: async function (input) {

                    // highlight-start
                    // we can send a custom response like this:
                    input.options.res.setStatusCode(200); // or any other status code
                    input.options.res.sendJSONResponse({
                        message: "my custom response",
                        //...
                    })
                    // highlight-end

                    // this return doesn't matter. But we must do it
                    // cause the function signature expects a response.
                    return {
                        status: "OK",
                        exists: false
                    };
                }
            }
        }
    }
})
```

</TabItem>
<TabItem value="go">

```go
thirdpartyemailpassword.Init(&tpepmodels.TypeInput{
    Override: &tpepmodels.OverrideStruct{
        APIs: func(originalImplementation tpepmodels.APIInterface) tpepmodels.APIInterface {

            (*originalImplementation.EmailExistsGET) = func(email string, options epmodels.APIOptions) (epmodels.EmailExistsGETResponse, error) {

                // highlight-start
                // we create our custom response.
                options.Res.Header().Set("Content-Type", "application/json; charset=utf-8")
                options.Res.WriteHeader(200)
                responseJson := map[string]interface{}{
                    "message": "My custom response",
                    // ...
                }

                bytes, _ := json.Marshal(responseJson)
                options.Res.Write(bytes)
                // highlight-end

                // this return doesn't matter. But we must do it
                // cause the function signature expects a response.
                return epmodels.EmailExistsGETResponse{
                    OK: &struct{ Exists bool }{
                        Exists: false,
                    },
                }, nil
            }

            return originalImplementation
        },
    },
})
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe.emailpassword.interfaces import APIOptions, EmailExistsGetOkResponse

def override_thirdpartyemailpassword_apis(original_implementation):

    async def email_exists_get(email: str, api_options: APIOptions):

        # highlight-start
        # send custom response like this
        api_options.response.set_status_code(200)  # or any other status code
        json_dict = {'message': 'Custom response'}
        api_options.response.set_json_content(json_dict)
        # highlight-end

        # this return doesn't matter. But we must do it
        # cause the function signature expects a response.
        return EmailExistsGetOkResponse(False)

    original_implementation.email_exists_get = email_exists_get
    return original_implementation


thirdpartyemailpassword.init(config={
    'override': {
        'apis': override_thirdpartyemailpassword_apis
    }
})
```

</TabItem>
</BackendSDKTabs>

## Method 2) By throwing an error and catching it

This method is useful in case you want to send a custom response from an overrided function which doesn't have access to the response object. This can happen in case you are overriding any of our recipe interface functions. 

Let's take an example in which we want to prevent a user from logging into a new device if a session already exists for them in another device. We also want to send a custom response from the API in case we are preventing a login. For this, we will be overriding the `createNewSession` function from the Session recipe.

In the override, we will check if a session already exists for the given userId, and if it does, we will throw an error from the function. This error will be propogated to your application's error handler (or an error handler callback if you have provided one to us), in which you can catch this and send a custom response.

### Step 1

First, we override the `createNewSession` function and throw an error in case a session already exists for a user. We can do this in the `Session.init` function:

<BackendSDKTabs>
<TabItem value="nodejs">

```js
Session.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
                createNewSession: async function (input) {
                    //highlight-start
                    const existingSessions = await Session.getAllSessionHandlesForUser(input.userId);
                    if (existingSessions.length > 0) {
                        // this means that the user already has a session on some other device
                        throw new Error("Session already exists on another device");
                    }

                    // no other session exists, and so we can continue with logging in this user
                    return originalImplementation.createNewSession(input);
                    //highlight-end
                }
            }
        }
    }
})
```

</TabItem>
<TabItem value="go">

```go
session.Init(&sessmodels.TypeInput{
	Override: &sessmodels.OverrideStruct{
		Functions: func(originalImplementation sessmodels.RecipeInterface) sessmodels.RecipeInterface {

			// first we copy the original implementation
			originalCreateNewSession := *originalImplementation.CreateNewSession

			(*originalImplementation.CreateNewSession) = func(res http.ResponseWriter, userID string, accessTokenPayload, sessionData map[string]interface{}) (sessmodels.SessionContainer, error) {
				// highlight-start
				existingSessions, err := session.GetAllSessionHandlesForUser(userID)
				if err != nil {
					return sessmodels.SessionContainer{}, err
				}

				if len(existingSessions) > 0 {
					// this means that the user already has a session on some other device
					return sessmodels.SessionContainer{}, errors.New("Session already exists on another device")
				}

				// no other session exists, and so we can continue with logging in this user
				return originalCreateNewSession(res, userID, accessTokenPayload, sessionData)
				// highlight-end
			}

			return originalImplementation

		},
	},
})
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe.session.asyncio import get_all_session_handles_for_user
from supertokens_python.recipe import session

def override_session_functions(original_implementation):

    # first we copy the original implementation
    original_create_new_session = original_implementation.create_new_session

    async def create_new_session(request, user_id: str, jwt_payload=None, session_data=None):
        # highlight-start
        existing_sessions = await get_all_session_handles_for_user(user_id)

        if len(existing_sessions) > 0:
            # this means that the user already has a session on some other device
            raise Exception("Session already exists on another device")

        # no other session exists, and so we can continue with logging in this user
        return await original_create_new_session(request, user_id, jwt_payload, session_data)
        # highlight-end

    original_implementation.create_new_session = create_new_session

    return original_implementation


session.init({
    "override": {
        'functions': override_session_functions
    }
})

```

</TabItem>
</BackendSDKTabs>

### Step 2

Next, we want to catch the thrown error and then send a custom response to the client

<BackendSDKTabs>
<TabItem value="nodejs">
<NodeJSFrameworkSubTabs>
<TabItem value="express">

```js

let app = express();

//...

// in your app's error handler, we catch the custom error
app.use((err, req, res, next) => {
    if (err.message === "Session already exists on another device") {
        // TODO: send a custom response using res
        return;
    }
    res.send(500).send(err.message)
})
```

</TabItem>
<TabItem value="hapi">

```js
// first we create a plugin to handle all errors from the app
const plugin = {
    name: "...",
    version: "...",
    register: async function (server, _) {
        server.ext("onPreResponse", async (request, h) => {
            if (request.response.isBoom) {
                let err = request.response.data;
                if (err.message === "Session already exists on another device") {
                    // TODO: send a custom response here with takeover
                }
            }
            return h.continue;
        });
    },
};

// then we register this plugin
(async() => {
    await server.register(plugin);
    
    await server.start();
})();
```
</TabItem>
<TabItem value="fastify">

```jsx
fastify.setErrorHandler(async (err: any, req, res) => {
    if (err.message === "Session already exists on another device") {
        // TODO: send a custom response here with takeover
    }
    // TODO: send a 500 error with the err.message
});
```

</TabItem>
<TabItem value="awsLambda">

```js
// this is in the auth.js file
let { middleware } = require("supertokens-node/framework/awsLambda");

module.exports.handler = middy(middleware()).use(cors({
    origin: getBackendConfig().appInfo.websiteDomain,
    credentials: true,
    headers: ["Content-Type", ...supertokens.getAllCORSHeaders()].join(", "),
    methods: "OPTIONS,POST,GET,PUT,DELETE"
})).onError(request => {
    if (request.error.message === "Session already exists on another device") {
        // TODO: send a custom response here with takeover
    }
    throw request.error;
});
```

</TabItem>
<TabItem value="koa">

```js
let {middleware} = require("supertokens-node/framework/koa");

let app = new Koa();

app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    if (err.message === "Session already exists on another device") {
        // TODO: return a custom response
    }
    throw err;
  }
})

app.use(middleware());
```

</TabItem>
<TabItem value="loopback">

```js
let {middleware} = require("supertokens-node/framework/loopback");

app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    if (err.message === "Session already exists on another device") {
        // TODO: return a custom response
    }
    throw err;
  }
})

app.use(middleware());
```

</TabItem>
<TabItem value="nextjs">

```js
// in the /auth/[[...path]].js file
export default async function superTokens(req, res) {
    //...
    try {
        await superTokensNextWrapper(
            async (next) => {
                await middleware()(req, res, next)
            },
            req,
            res
        )
    } catch (err) {
        if (err.message === "Session already exists on another device") {
            // TODO: send custom reply
        }
        throw err;
    }

    //...
}
```

</TabItem>
<TabItem value="nestjs">

```tsx
// we want to add our own error handler which will catch the special exception

@Catch(Error)
export class AppErrorHandler implements ExceptionFilter {

  catch(exception: Error, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    if (exception.message === "Session already exists on another device") {
        // TODO: send custom error using ctx.getResponse<Response>()
    } else {
        throw exception;
    }
  }
}
```
</TabItem>
</NodeJSFrameworkSubTabs>
</TabItem>
<TabItem value="go">

```go
supertokens.Init(supertokens.TypeInput{
	OnGeneralError: func(err error, req *http.Request, res http.ResponseWriter) {
		if err.Error() == "Session already exists on another device" {
			// TODO: send custom error
		}
		// TODO: send generic error
	},
})
```

</TabItem>
<TabItem value="python">


</TabItem>
</BackendSDKTabs>