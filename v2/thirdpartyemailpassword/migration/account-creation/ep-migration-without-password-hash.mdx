---
id: ep-migration-without-password-hash
title: User Creation without password hahes
hide_title: true
---
# User Creation without password hahes

:::caution
The recommended method for migrating users to SuperTokens is by [importing users with their password hashes](./user-creation).
You should only use the following method if you do not have access to your user's password hashes and still have access to your previous identity provider.
:::

Supertokens also supports the "**just in time**" user migration strategy for when password hashes cannot be exported from your legacy provider.
In this approach, the login flow is modified so that if a legacy user tries to authenticate, SuperTokens will check if the user exists in the legacy provider and whether the input credentials are valid.
If the user exists in the leagacy provider and the credentials are valid, SuperTokens will retrieve the user data from the legacy provider and create a corresponding SuperTokens user account. 

To implement this flow we will first override the function that handles Email-Password based login when initializing the `ThirdPartyEmailPassword` recipe on the backend.

:::info
The following code is implemented for Nodejs, but similar changes can be made for other tech stacks.
:::

```tsx
import SuperTokens from "supertokens-node"
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import EmailVerification from "supertokens-node/recipe/emailverification"

ThirdPartyEmailPassword.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
                // EmailPassword Login function modification
                emailPasswordSignIn: async function (input) {

                    // Check if the user exists in the legacy identity provider, doesUserExistInLegacyProvider() is a function defined by you
                    // TODO: doesUserExistInLegacyProvider() is a function defined by you
                    // @ts-ignore
                    if (await doesUserExistInLegacyProvider(input.email)) {

                        // Check if an email-password user with the input email exists in SuperTokens
                        let superTokensUsers = await this.getUsersByEmail({ email: input.email, userContext: input.userContext });
                        let emailPasswordUser = undefined;

                        for (let i = 0; i < superTokensUsers.length; i++) {
                            // if the thirdParty field in the user object is undefined, then the user is an EmailPassword account.
                            if (superTokensUsers[i].thirdParty === undefined) {
                                emailPasswordUser = superTokensUsers[i]
                                break;
                            }
                        }

                        if(emailPasswordUser === undefined){
                            // EmailPassword user does not exist in SuperTokens 
                            // Validate user credentials in the legacy provider
                            // TODO: validateAndGetUserInfoFromLegacyProvider() is a function defined by you
                            // @ts-ignore
                            let legacyUserData = await validateAndGetUserInfoFromLegacyProvider(input.email, input.password)

                            if (legacyUserData !== undefined) {
                                // Call the signup function to create a new SuperTokens user.
                                let response = await this.emailPasswordSignUp(input)

                                if (response.status !== "OK") {
                                    return {
                                        status: "WRONG_CREDENTIALS_ERROR",
                                    };
                                }
                                // Map the legacy userId to the SuperTokens userId
                                // If you have not stored the legacy userId in your tables, you can ignore this step
                                // @ts-ignore
                                await SuperTokens.createUserIdMapping({ superTokensUserId: response.user.id, externalUserId: legacyUserData.user_id})

                                // Set the userId in the response to use the external userId.
                                // If you have not stored the users external userId in your tables, you can ignore this step
                                // @ts-ignore
                                response.user.id = legacyUserData.user_id;

                                // We will also need to set the email verification status of the user
                                if(legacyUserData.isEmailVerified){
                                    // generate an email verification token for the user
                                    let generateEmailVerificationTokenResponse = await  EmailVerification.createEmailVerificationToken(response.user.id, input.email, input.userContext);

                                    if(generateEmailVerificationTokenResponse.status === "OK"){
                                        // verify the user's email
                                        await EmailVerification.verifyEmailUsingToken(generateEmailVerificationTokenResponse.token, input.userContext);
                                    }
                                }

                                // TODO: You could also assign Roles and Metadata to the user at this point
                                
                                return response;
                            }

                            // Credentials are incorrect in the external provider
                            return {
                                status: "WRONG_CREDENTIALS_ERROR"
                            }
                        }
                    } 
                    // user does not exist in the external provider so we call the original implementation
                    return originalImplementation.emailPasswordSignIn(input)
                },
            }
        },
    }    
})
```

You will also need to account for user's who have forgotten their passwords. We will need to modify the reset password flow to account for this.

```tsx
import SuperTokens from "supertokens-node"
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import EmailVerification from "supertokens-node/recipe/emailverification"

ThirdPartyEmailPassword.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
            }
        },
        apis: (originalImplementation) => {
            return {
                ...originalImplementation,
                // this api handles the generation of the password reset token 
                generatePasswordResetTokenPOST: async (input) => {
                    if(originalImplementation.generatePasswordResetTokenPOST === undefined){
                        throw new Error("Should never come here");
                    }

                    // retrive email from input
                    let email = input.formFields.find(i => i.id === "email");

                    if(email === undefined){
                        throw new Error("Should never come here")
                    }

                    // check if user exists in SuperTokens
                    let superTokensUsers = await ThirdPartyEmailPassword.getUsersByEmail(email.value, input.userContext);
                    
                    let emailPasswordUser = undefined;

                    for (let i = 0; i < superTokensUsers.length; i++) {
                        // if the thirdParty field in the user object is undefined, then the user is an EmailPassword account.
                        if (superTokensUsers[i].thirdParty === undefined) {
                            emailPasswordUser = superTokensUsers[i]
                            break;
                        }
                    }
                    
                    // check that the user does not exist in SuperTokens
                    if(emailPasswordUser === undefined){
                        // check if the user exists in the external provider and retrieve their data
                        // TODO: retrieveUserDataFromLegacyProvider() is a function defined by you
                        // @ts-ignore
                        let legacyUserData = retrieveUserDataFromLegacyProvider(email.value)
                        if(legacyUserData){
                            // Create a SuperTokens account for the user, we will generate the account with a temporary password
                            // TODO: generateRandomPassword() is function defined by you
                            // @ts-ignore
                            let tempPassword = generateRandomPassword(); 
                            let signupResponse = await ThirdPartyEmailPassword.emailPasswordSignUp(email.value, tempPassword, input.userContext);

                            if(signupResponse.status === "OK"){
                                
                                // We will also need to set the email verification status of the user
                                if(legacyUserData.isEmailVerified){
                                    // Generate an email verification token for the user
                                    let generateEmailVerificationTokenResponse = await  EmailVerification.createEmailVerificationToken(signupResponse.user.id, email.value, input.userContext);

                                    if(generateEmailVerificationTokenResponse.status === "OK"){
                                        // Verify the user's email
                                        await EmailVerification.verifyEmailUsingToken(generateEmailVerificationTokenResponse.token, input.userContext);
                                    }
                                }

                                // If user is succesfully created  we will map the external id to their SuperTokens Id. 
                                // If you have not stored the users external userId in your tables, you can ignore this step.
                                SuperTokens.createUserIdMapping({
                                    superTokensUserId: signupResponse.user.id,
                                    externalUserId: legacyUserData.user_id
                                })
                                // TODO: You could also assign Roles and Metadata to the user at this point
                            }
                        }   
                    }
                    return await originalImplementation.generatePasswordResetTokenPOST(input);
                },
            }
        }
    }    
})
```


