---
id: ep-migration-without-password-hash
title: User Creation without password hahes
hide_title: true
---
# User Creation without password hahes

:::caution
The recommended method for migrating users to SuperTokens is by [importing users with their password hashes](./user-creation).
You should only use the following method if you do not have access to your user's password hashes and still have access to your previous identity provider.
:::

Supertokens also supports the "**just in time**" user migration strategy for when password hashes cannot be exported from your legacy provider.
In this approach, the login flow is modified so that if a legacy user tries to authenticate, SuperTokens will check if the user exists in the legacy provider and whether the input credentials are valid.
If the user exists in the leagacy provider and the credentials are valid, SuperTokens will retrieve the user data from the legacy provider and create a corresponding SuperTokens user account. 

To implement this flow we will first override the function that handles Email-Password based login when initializing the `ThirdPartyEmailPassword` recipe on the backend.

:::info
The following code is implemented for Nodejs, but similar changes can be made for other tech stacks.
:::


```tsx
import SuperTokens from "supertokens-node"
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";

ThirdPartyEmailPassword.init({
    override: {
        functions: (originalImpl) => {
            return {
                ...originalImpl,
                // EmailPassword Login function modification
                emailPasswordSignIn: async function (input) {

                    // Check if the user exists in the legacy identity provider
                    // @ts-ignore
                    if (await doesUserExistInLegacyProvider(input.email)) {

                        // Check if user exists in SuperTokens
                        let superTokensUsers = await this.getUsersByEmail({ email: input.email, userContext: input.userContext });
                        let emailPasswordUser = undefined;

                        for (let i = 0; i < superTokensUsers.length; i++) {
                            // if the thirdParty field in the user object is undefined, then the user is an EmailPassword account.
                            if (superTokensUsers[i].thirdParty === undefined) {
                                emailPasswordUser = superTokensUsers[i]
                                break;
                            }
                        }

                        if(emailPasswordUser === undefined){
                            // EmailPassword user does not exist in SuperTokens 
                            // Validate user credentials in the legacy provider
                            // @ts-ignore
                            let legacyUserData = await validateAndGetUserInfoFromLegacyProvider(input.email, input.password)

                            if (legacyUserData !== undefined) {
                                // Call the signup function to create a new SuperTokens user.
                                let response = await this.emailPasswordSignUp(input)

                                if (response.status !== "OK") {
                                    return {
                                        status: "WRONG_CREDENTIALS_ERROR",
                                    };
                                }


                                // Map the external userId to the SuperTokens userId
                                // If you have not stored the users external userId in your tables, you can ignore this step
                                // @ts-ignore
                                await SuperTokens.createUserIdMapping({ superTokensUserId: response.user.id, externalUserId: externalUserData.user_id})

                                // Set the userId in the response to use the external userId.
                                // If you have not stored the users external userId in your tables, you can ignore this step
                                // @ts-ignore
                                response.user.id = externalUserData.user_id;
                                
                                return response;
                            }

                            // Credentials are incorrect in the external provider
                            return {
                                status: "WRONG_CREDENTIALS_ERROR"
                            }
                        }
                    } 

                    // Box 4: user does not exist in Auth0 call original signIn implementation
                    return originalImpl.emailPasswordSignIn(input)
                },
            }
        },
        apis: (originalImplementation) => {
            return {
                ...originalImplementation,
                generatePasswordResetTokenPOST: async (input) =>{
                    if(originalImplementation.generatePasswordResetTokenPOST === undefined){
                        throw new Error("Should never come here");
                    }

                    // retrive email from input
                    let email = input.formFields.find(i => i.id === "email");

                    if(email === undefined){
                        throw new Error("Should never come here")
                    }

                    // check if user exists in SuperTokens
                    let superTokensUsers = await ThirdPartyEmailPassword.getUsersByEmail(email.value, input.userContext);
                    
                    let emailPasswordUser = undefined;

                    for (let i = 0; i < superTokensUsers.length; i++) {
                        // if the thirdParty field in the user object is undefined, then the user is an EmailPassword account.
                        if (superTokensUsers[i].thirdParty === undefined) {
                            emailPasswordUser = superTokensUsers[i]
                            break;
                        }
                    }
                    
                    // check that the user does not exist in SuperTokens
                    if(emailPasswordUser === undefined){
                        // check if the user exists in the external provider and retrieve their data
                        // retrieveUserDataFromExternalProvider() is a function defined by you
                        // @ts-ignore
                        let externalUserData = retrieveUserDataFromExternalProvider(email.value)
                        if(externalUserData){
                            // create a SuperTokens account for the user, we will generate the account with a temporary password
                            // generateRandomPassword() is function defined by you
                            // @ts-ignore
                            let tempPassword = generateRandomPassword(); 
                            let signupResponse = await ThirdPartyEmailPassword.emailPasswordSignUp(email.value, tempPassword, input.userContext);

                            if(signupResponse.status === "OK"){
                                // if user is succesfully created  we will map the external id to their SuperTokens Id. 
                                // If you have not stored the users external userId in your tables, you can ignore this step
                                SuperTokens.createUserIdMapping({
                                    superTokensUserId: signupResponse.user.id,
                                    externalUserId: externalUserData.user_id
                                })
                            }
                        }   
                    }

                    return await originalImplementation.generatePasswordResetTokenPOST(input);
                },
            }
        }
    }    
})
```


