---
id: ep-migration-without-password-hash
title: User Creation without password hashes
hide_title: true
---
# User Creation without password hashes

:::caution
The recommended method for migrating users to SuperTokens is by [importing users with their password hashes](./user-creation).
You should only use the following method if you do not have access to your user's password hashes and still have access to your previous identity provider.
:::

SuperTokens also supports the "**just in time**" user migration strategy for when password hashes cannot be exported from your legacy provider.

In this approach, the login flow is modified so that if a legacy user tries to authenticate, SuperTokens will check if the user exists in the legacy provider and whether the input credentials are valid and if so, SuperTokens will retrieve the user data from the legacy provider and create a corresponding SuperTokens user account.

## Step 1) Override Login flow to support user migration 

To implement this flow we will first override the function that handles Email-Password based login when initializing the `ThirdPartyEmailPassword` recipe on the backend.

```tsx
import SuperTokens from "supertokens-node"
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import EmailVerification from "supertokens-node/recipe/emailverification"

ThirdPartyEmailPassword.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
                emailPasswordSignIn: async function (input) {

                    // Check if the user exists in the legacy identity provider, doesUserExistInLegacyProvider() is a function defined by you
                    if (await doesUserExistInExternalProvider(input.email)) {

                        // Check if an email-password user with the input email exists in SuperTokens
                        let superTokensUsers = await this.getUsersByEmail({ email: input.email, userContext: input.userContext });
                        let emailPasswordUser = undefined;

                        for (let i = 0; i < superTokensUsers.length; i++) {
                            // if the thirdParty field in the user object is undefined, then the user is an EmailPassword account.
                            if (superTokensUsers[i].thirdParty === undefined) {
                                emailPasswordUser = superTokensUsers[i]
                                break;
                            }
                        }

                        if (emailPasswordUser === undefined) {
                            // EmailPassword user does not exist in SuperTokens 
                            // Validate user credentials in the external provider
                            let legacyUserInfo = await validateAndGetUserInfoFromExternalProvider(input.email, input.password)

                            if (legacyUserInfo === undefined) {
                                // Credentials are incorrect in the external provider
                                return {
                                    status: "WRONG_CREDENTIALS_ERROR"
                                }
                            }

                            // Call the signup function to create a new SuperTokens user.
                            let response = await ThirdPartyEmailPassword.emailPasswordSignUp(input.email, input.password, input.userContext);

                            if (response.status !== "OK") {
                                throw new Error("Should never come here");
                            }

                            // Map the legacy userId to the SuperTokens userId
                            await SuperTokens.createUserIdMapping({ superTokensUserId: response.user.id, externalUserId: legacyUserInfo.user_id })

                            // Set the userId in the response to use the external userId.
                            response.user.id = legacyUserInfo.user_id;

                            // We will also need to set the email verification status of the user
                            if (legacyUserInfo.isEmailVerified) {
                                // generate an email verification token for the user
                                let generateEmailVerificationTokenResponse = await EmailVerification.createEmailVerificationToken(response.user.id, input.email, input.userContext);

                                if (generateEmailVerificationTokenResponse.status === "OK") {
                                    // verify the user's email
                                    await EmailVerification.verifyEmailUsingToken(generateEmailVerificationTokenResponse.token, input.userContext);
                                }
                            }
                            return response;
                        }
                    }
                    // user does not exist in the external provider so we call the original implementation
                    return originalImplementation.emailPasswordSignIn(input)
                },
            }
        },
    }
})

async function doesUserExistInExternalProvider(email: string): Promise<boolean> {
    // TODO: check if user with the input email exists in the external provider
    return false;
}

async function validateAndGetUserInfoFromExternalProvider(email: string, password: string): Promise<{
    user_id: string,
    isEmailVerified: boolean
} | undefined> {
    // TODO: Validate the input credentials against the external authentication provider. If the credentials are valid return the user info.
    return undefined
}
```

## Step 2) Override password reset flow to support user migration

The migration flow will also need to account for users who have forgotten their passwords. In this case the reset password flow will need to be modified: 

```tsx
import SuperTokens from "supertokens-node"
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import EmailVerification from "supertokens-node/recipe/emailverification"

ThirdPartyEmailPassword.init({
    override: {
        functions: (originalImplementation) => {
            return {
                ...originalImplementation,
                // TODO: implementation details in previous step
            }
        },
        apis: (originalImplementation) => {
            return {
                ...originalImplementation,
                generatePasswordResetTokenPOST: async (input) => {
                    if (originalImplementation.generatePasswordResetTokenPOST === undefined) {
                        throw new Error("Should never come here");
                    }

                    // retrive email from input
                    let email = input.formFields.find(i => i.id === "email")!.value;

                    // check if user exists in SuperTokens
                    let superTokensUsers = await ThirdPartyEmailPassword.getUsersByEmail(email, input.userContext);

                    let emailPasswordUser = undefined;

                    for (let i = 0; i < superTokensUsers.length; i++) {
                        // if the thirdParty field in the user object is undefined, then the user is an EmailPassword account.
                        if (superTokensUsers[i].thirdParty === undefined) {
                            emailPasswordUser = superTokensUsers[i]
                            break;
                        }
                    }

                    // check that the user does not exist in SuperTokens
                    if (emailPasswordUser === undefined) {
                        // check if the user exists in the legacy provider and retrieve their data
                        let legacyUserData = await retrieveUserDataFromExternalProvider(email);
                        if (legacyUserData) {
                            // Create a SuperTokens account for the user, we will generate the account with a temporary password
                            let tempPassword = await generatePassword();
                            let signupResponse = await ThirdPartyEmailPassword.emailPasswordSignUp(email, tempPassword, input.userContext);

                            if (signupResponse.status === "OK") {

                                // If user is succesfully created  we will map the legacy id to their SuperTokens Id. 
                                SuperTokens.createUserIdMapping({
                                    superTokensUserId: signupResponse.user.id,
                                    externalUserId: legacyUserData.user_id
                                })

                                // We will also need to set the email verification status of the user
                                if (legacyUserData.isEmailVerified) {
                                    // Generate an email verification token for the user
                                    let generateEmailVerificationTokenResponse = await EmailVerification.createEmailVerificationToken(legacyUserData.user_id, email, input.userContext);

                                    if (generateEmailVerificationTokenResponse.status === "OK") {
                                        // Verify the user's email
                                        await EmailVerification.verifyEmailUsingToken(generateEmailVerificationTokenResponse.token, input.userContext);
                                    }
                                }
                            } else {
                                throw new Error("Shoulc never come here")
                            }
                        }
                    }
                    return await originalImplementation.generatePasswordResetTokenPOST(input);
                },
            }
        }
    }
})

async function generatePassword(): Promise<string> {
    // TODO: generate a random password 
    return ""
}

async function retrieveUserDataFromExternalProvider(email: string): Promise<{
    user_id: string,
    isEmailVerified: boolean
} | undefined> {
    // TODO: retrieve user data if a user with the input email exists in the external provider.
    return undefined;
}
```


