---
id: modifications-to-login
title: Modifications to login
hide_title: true
---
import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';


# Modifications to Login

In this section we will be modifying login to enable the migrating of users with EmailPassword or Social accounts from Auth0 to SuperTokens. 

To get started, you will first need to setup SuperTokens on your frontend and backend. You can do so by following the [quick setup](/docs/thirdpartyemailpassword/quick-setup/frontend)

:::info
The following code is implemented for Nodejs, but, you can apply the same logic in your own tech stack.
:::

## Flow 

<img src="/img/thirdpartyemailpassword/user-migration-flow.png" />

## Implementation

We will be overriding SuperToken's login functions to enable account migration, if a user signs up, a new SuperTokens account will be created so no changes need to be made to the sign up functionality. 

### Modifying the `signInUp` and `signIn` functions on the backend:

```jsx title="Nodejs"
ThirdPartyEmailPassword.init({
    override: {
        functions: (orignalImpl) => {
            return {
                ...orignalImpl,
                // EmailPassword Login function modification
                signIn: async function (input) {

                    // Step 2: check if the User exists in Auth0
                    if( await doesEmailPasswordUserExistInAuth0(input.email) !== undefined){

                        // Step 3: check if user exists in SuperTokens
                        let superTokensUsers = await this.getUsersByEmail({ email: input.email });
                        let emailPasswordUserExists = false;

                        // check that if SuperTokens user exits, they are not an EmailPassword User
                        for (let i = 0; i < superTokensUsers.length; i++) {
                            if (users[i].thirdParty === undefined) {
                                emailPasswordUserExists = true
                            }
                        }

                        let response;
                        if( !emailPasswordUserExists ){
                            // EmailPassword User with the input credentials does not exist in SuperTokens

                            // Step 6: validate users credentials in Auth0
                            let auth0UserInfo = await validateEmailPasswordUserInAuth0( input.email, input.passoword)

                            if ( auth0UserInfo === undefined ){
                                // Step 10: return WRONG_CREDENTIALS_ERROR
                                return {
                                     status: "WRONG_CREDENTIALS_ERROR"
                                }
                            }

                            // Step 8: call the signup function to create a new SuperTokens user.
                            response = await this.signUp(input)
                            // Step 9: map the Auth0 userId to the SuperTokens userId
                            setAuth0ToSuperTokensUserIdMapping({ auth0UserId: auth0UserData.sub, supertokensUserId: response.user.id})                          

                        } else {
                            // Step 4: EmailPassword User with the input credentials exists in SuperTokens, so call the orignal signIn implementation
                            response = await orignalImpl.signIn(input)
                        }

                        // Step 5: Set the userId in the response to use the Auth0 userId.
                        response.user.id = auth0UserData.sub
                        return response

                    } else {
                        // Step 11: user does not exist in Auth0 call orignal signIn implementation
                        return orignalImpl.signIn(input)
                    }                    
                },
                // Social Login function modification
                signInUp: async function (input) {

                    // Step 2: check if a user with the input ThirdParty userId exists in Auth0
                    let auth0SocialUserId = await doesThirdPartyUserIdExistInAuth0(response.user.thirdParty.userId)

                    if (auth0SocialUserId !== undefined){
                        
                        let response = await orignalImpl.signInUp(input)
                        
                        // Step 3: check if user existed in SuperTokens
                        if (response.createdNewUser){
                            // Step 9: map the Auth0 userId to the SuperTokens userId
                            setAuth0ToSuperTokensUserIdMapping({ auth0UserId: auth0SocialUserId, supertokensUserId: response.user.id})
                            // Set the newly created flag value to false in the response
                            response.createdNewUser = false
                        }
                        
                        // Step 5: Set the userId in the response to use the Auth0 userId.
                        response.user.id = auth0SocialUserId

                        return response

                    } else {
                        // Step 11: Auth0 user does not exist
                        return await orignalImpl.signInUp(input)
                    }
                }
            }
        }
    },
})

```

After making the changes mentioned above you can now decide how you would like to migrate your users:

There are two methods of migrating user accounts:
- Using Auth0's APIs
- Using the exported user data and password hashes from Auth0

<Tabs
    groupId="migration-methods"  
    defaultValue="method-1"
    values={[
        {label: "Using Auth0's APIs", value: 'method-1'},
        {label: 'Using the exported Auth0 user data and password hashes. ', value: 'method-2'},
]}>

<TabItem value="method-1">

## Using Auth0's APIs

In this method we will be using Auth0's APIs to check if the user signing in is an Auth0 user.

### Prerequisites
- This method assumes you have access to your Auth0 account and database for the complete duration of user migration.
- To enable email and password validation, you will need to add the database connection name to the `Default Directory` field in your Auth0 tenant settings.

For example:
- The default connection name for the database is `Username-Password-Authentication`, you can find your database connections under Authentication -> Database on your Auth0 dashboard.

<img src="/img/thirdpartyemailpassword/auth0-database.png" />

- Set your database connection name in your `Default Directory` field in your tennant settings.

<img src="/img/thirdpartyemailpassword/default-directory-settings.png" />

### Implementation

Implementation for the `doesThirdPartyUserIdExistInAuth0`, `validateEmailPasswordUserInAuth0` and `doesEmailPasswordUserExistInAuth0` functions used in [this](#modifying-the-signinup-and-signin-functions-on-the-backend) section:

The functions below uses Auth0's Authentication and Management APIs to access user information and validate credentials. Please refer to their [documentation](https://auth0.com/docs/api) to get the complete spec for the APIs used below.

```jsx title="Nodejs"

// Used in Step 6 of the flow diagram
let validateEmailPasswordUserInAuth0 = async (email, password) => {

    try {
        // generate an user access token using the input credentials
        let access_token = (await axios({
            method: "post",
            // TODO: add your Auth0 domain 
            url: "https://YOUR_AUTH0_DOMAIN/oauth/token",
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
            },
            data: {
                client_id: "YOUR_CLIENT_ID",
                grant_type: "password",
                username: email,
                password: password,
            }
        })).data.access_token;

        // retive the users info using the access token if valid crendentials were passed
        let userResponse = await axios.get("https://YOUR_AUTH0_DOMAIN/userInfo", {
            headers: { "authorization": `Bearer ${access_token}` },
        })
        return userResponse.data

    } catch (error) {
        // user does not exist in Auth0
        return undefined
    }
}

// Used in Step 2 of the flow diagram
let doesEmailPasswordUserExistInAuth0 = async (email) => {

    try {
        // generate an access_token so you can use the Auth0 management API
        let access_token = (await axios({
            method: 'POST',
            url: "https://YOUR_DOMAIN/oauth/token",
            headers: { 'content-type': 'application/json' },
            data: {
                client_id: "CLIENT_ID",
                client_secret: "CLIENT_SECRET",
                audience: "https://YOUR_DOMAIN/api/v2/",
                grant_type: "client_credentials"
            }
        })).data.access_token

        // get the user info with userId as the identifier.
        let response = await axios({
            method: 'GET',
            url: "https://YOUR_DOMAIN/api/v2/users",
            params: { q: `identities.isSocial:false AND  email:${email}` },
            headers: { authorization: `Bearer ${access_token}` }
        })
        return response.data[0]

    } catch (error) {
        // User does not exist in Auth0
        return undefined
    }
}

let doesThirdPartyUserIdExistInAuth0 = async (userId) => {
    
    try {
        // generate an access_token so you can use the Auth0 management API
        let access_token = (await axios({
            method: 'POST',
            url: "https://YOUR_DOMAIN/oauth/token",
            headers: { 'content-type': 'application/json' },
            data: {
                client_id: "CLIENT_ID",
                client_secret: "CLIENT_SECRET",
                audience: "https://YOUR_DOMAIN/api/v2/",
                grant_type: "client_credentials"
            }
        })).data.access_token

        // get the user info with userId as the identifier.
        let response = await axios({
            method: 'GET',
            url: "https://YOUR_DOMAIN/api/v2/users",
            params: { q: `identities.user_id:"${userId}"` },
            headers: { authorization: `Bearer ${access_token}` }
        })
        return response.data[0].user_id

    } catch (error) {

        // User does not exist in Auth0
        return undefined
    }
}

```

</TabItem>

<TabItem value="method-2">

##  Using the exported Auth0 user data and password hashes. 

- By default Auth0 uses `bcrypt` to hash passwords with `$2a$` or `$2b$` identifiers and have 10 `saltRounds`.

### Prerequisites
- This method assumes you can export your Auth0 user data and have an enterprise account to export password hashes.
- You can refer to the following guides on how to export your [user data](https://auth0.com/docs/users/import-and-export-users/bulk-user-exports) and [password hashes](https://auth0.com/docs/support/manage-subscriptions/export-data).


### Implementation

Implementation for the `doesThirdPartyUserIdExistInAuth0`, `validateEmailPasswordUserInAuth0` and `doesEmailPasswordUserExistInAuth0` functions used in [this](#modifying-the-signinup-and-signin-functions-on-the-backend) section:

```jsx
let bcrypt = require("bcryptjs")

// Used in Step 6 of the flow diagram
let validateEmailPasswordUserInAuth0 = async (email, password) => {

    try {

        // read exported Auth0 user info and password hashes
        let auth0UsersDataString = fs.readFileSync(__dirname + auth0ExportedUsersDataFile)
        let auth0UsersData = JSON.parse(auth0UsersDataString);
        // get auth0 user info
        let auth0UsersInfo = auth0UsersData.userData
        // get auth0 password hashes
        let auth0PasswordHashes = auth0UsersData.passwordHashes


        // check if input email has an associated user
        for (let i = 0; i < auth0UsersInfo.length; i++) {
            if ((!auth0UsersInfo[i].identities[0].isSocial) && auth0UsersInfo[i].email === email) {

                // get password hash from associated userid
                let usersPasswordHash = getPasswordHashFromUserId(auth0UsersInfo[i].identities[0].user_id, auth0PasswordHashes)
                if (verifyPasswordhash(password, usersPasswordHash)) {
                    return auth0UsersInfo[i]
                }
            }
        }
        return undefined

    } catch (error) {
        return undefined
    }
}

// Used in Step 2 of the flow diagram
let doesEmailPasswordUserExistInAuth0 = async (email) => {

    try {

        // read exported Auth0 user info and password hashes
        let auth0UsersDataString = fs.readFileSync(__dirname + auth0ExportedUsersDataFile)
        let auth0UsersData = JSON.parse(auth0UsersDataString);
        // get auth0 user info
        let auth0UsersInfo = auth0UsersData.userData

        // check if input email has an associated user
        for (let i = 0; i < auth0UsersInfo.length; i++) {
            if ((!auth0UsersInfo[i].identities[0].isSocial) && auth0UsersInfo[i].email === email) {

                return auth0UsersInfo[i]
            }
        }
        return undefined

    } catch (error) {
        return undefined
    }
}

let doesThirdPartyUserIdExistInAuth0 = async (userId) => {

    try {
        // read exported Auth0 user info and password hashes
        let auth0UsersDataString = fs.readFileSync(__dirname + auth0ExportedUsersDataFile)
        let auth0UsersData = JSON.parse(auth0UsersDataString);
        // get auth0 user info
        let auth0UsersInfo = auth0UsersData.userData

        for (let i = 0; i < auth0UsersInfo.length; i++) {

             // check if input userId has an associated user which is social and userId matches 
            if ((auth0UsersInfo[i].identities[0].isSocial) && auth0UsersInfo[i].identities[0].user_id === userId) {
                
                return auth0UsersInfo[i]
            }
        }
        return undefined

    } catch (error) {
        return undefined
    }
}


function getPasswordHashFromUserId(userId, auth0PasswordHashes) {

    // retrive the password hash associated with the input userId.
    for (let i = 0; i < auth0PasswordHashes.length; i++) {
        if (auth0PasswordHashes[i]._id.$oid === userId) {
            return auth0PasswordHashes[i].passwordHash
        }
    }
    return undefined
}

function verifyPasswordhash(password, passwordHash) {

    // verify password with password hash
    if (passwordHash === undefined) {
        return false
    }
    return bcrypt.compareSync(password, passwordHash)
}
```

</TabItem>
</Tabs>

We can now move on to the next section discussing how userId's should be mapped.