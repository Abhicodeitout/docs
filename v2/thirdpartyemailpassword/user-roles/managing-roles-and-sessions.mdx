---
sidebar_position: 1
title: Managing roles and sessions
hide_title: true
---

<!-- COPY DOCS -->
<!-- ./userroles/managing-roles-and-sessions.mdx -->

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import NodeJSFrameworkSubTabs from "/src/components/tabs/NodeJSFrameworkSubTabs";
import GoFrameworkSubTabs from "/src/components/tabs/GoFrameworkSubTabs"
import PythonFrameworkSubTabs from "/src/components/tabs/PythonFrameworkSubTabs";
import TabItem from '@theme/TabItem';

# Managing roles and sessions

After you create a role and assign it to as user, you can add the role information to the session. You can then use this information to read and verify the role and permissions in your API and website routes

## Adding roles to a session

### 1) During user login / sign up

We can set the user's role in the access token by overriding the `createNewSession` function in the `init` function:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";
import UserRoles from "supertokens-node/recipe/userroles";

SuperTokens.init({
    supertokens: {
        connectionURI: "...",
    },
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init({
            // highlight-start
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        createNewSession: async function (input) {
                            let userId = input.userId;

                            let roles = await UserRoles.getRolesForUser(userId);

                            input.accessTokenPayload = {
                                ...input.accessTokenPayload,
                                roles
                            };

                            return originalImplementation.createNewSession(input);
                        },
                    };
                },
            },
            // highlight-end
        })
    ]
});
```
</TabItem>
<TabItem value="go">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
    supertokens.Init(supertokens.TypeInput{
        Supertokens: &supertokens.ConnectionInfo{
            ConnectionURI: "...",
        },
        AppInfo: supertokens.AppInfo{
            APIDomain:     "...",
            AppName:       "...",
            WebsiteDomain: "...",
        },
        RecipeList: []supertokens.Recipe{
            session.Init(&sessmodels.TypeInput{
                // highlight-start
                Override: &sessmodels.OverrideStruct{
                    Functions: func(originalImplementation sessmodels.RecipeInterface) sessmodels.RecipeInterface {
                        oCreateNewSession := *originalImplementation.CreateNewSession
                        nCreateNewSession := func(res http.ResponseWriter, userID string, accessTokenPayload map[string]interface{}, sessionData map[string]interface{}, userContext supertokens.UserContext) (sessmodels.SessionContainer, error) {
                            response, err := userroles.GetRolesForUser(userID, userContext)
                            if err != nil {
                                return sessmodels.SessionContainer{}, err
                            }
                            accessTokenPayload["roles"] = response.OK.Roles
                            return oCreateNewSession(res, userID, accessTokenPayload, sessionData, userContext)
                        }
                        *originalImplementation.CreateNewSession = nCreateNewSession
                        return originalImplementation
                    },
                },
                // highlight-end
            }),
        },
    })
}
```

</TabItem>
<TabItem value="python">

TODO
</TabItem>
</BackendSDKTabs>

### 2) In any API call post login

Post session verification, you can use the `updateAccessTokenPayload` function to store the user's role:

<BackendSDKTabs>
<TabItem value="nodejs">
<NodeJSFrameworkSubTabs>
<TabItem value="express">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import express from "express";
import { SessionRequest } from "supertokens-node/framework/express";
import UserRoles from "supertokens-node/recipe/userroles";

let app = express();

app.post("/set-role", verifySession(), async (req: SessionRequest, res) => {

    let userId = req.session!.getUserId();

    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    // highlight-start
    await req.session!.updateAccessTokenPayload(
        { roles }
    );
    // highlight-end

    //....
});
```
</TabItem>
<TabItem value="hapi">

```tsx
import Hapi from "@hapi/hapi";
import { verifySession } from "supertokens-node/recipe/session/framework/hapi";
import {SessionRequest} from "supertokens-node/framework/hapi";
import UserRoles from "supertokens-node/recipe/userroles";

let server = Hapi.server({ port: 8000 });

server.route({
    path: "/set-role",
    method: "post",
    options: {
        pre: [
            {
                method: verifySession()
            },
        ],
    },
    handler: async (req: SessionRequest, res) => {
        let userId = req.session!.getUserId();

        let roles = (await UserRoles.getRolesForUser(userId)).roles;

        // Note that this will override any existing access token payload
        // that you may have provided earlier.
        // highlight-start
        // highlight-start
        await req.session!.updateAccessTokenPayload(
            { roles }
        );
        // highlight-end

        //....
    }
})
```
</TabItem>
<TabItem value="fastify">

```tsx
import Fastify from "fastify";
import { verifySession } from "supertokens-node/recipe/session/framework/fastify";
import { SessionRequest } from "supertokens-node/framework/fastify";
import UserRoles from "supertokens-node/recipe/userroles";

let fastify = Fastify();

fastify.post("/set-role", {
    preHandler: verifySession(),
}, async (req: SessionRequest, res) => {
    let userId = req.session!.getUserId();

    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    // highlight-start
    await req.session!.updateAccessTokenPayload(
        { roles }
    );
    // highlight-end

    //....
});
```

</TabItem>
<TabItem value="awsLambda">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/awsLambda";
import { SessionEvent } from "supertokens-node/framework/awsLambda";
import UserRoles from "supertokens-node/recipe/userroles";

async function setRole(awsEvent: SessionEvent) {
    let userId = awsEvent.session!.getUserId();

    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    // highlight-start
    await awsEvent.session!.updateAccessTokenPayload(
        { roles }
    );
    // highlight-end

    //....
};

exports.handler = verifySession(setRole);
```

</TabItem>
<TabItem value="koa">

```tsx
import KoaRouter from "koa-router";
import { verifySession } from "supertokens-node/recipe/session/framework/koa";
import {SessionContext} from "supertokens-node/framework/koa";
import UserRoles from "supertokens-node/recipe/userroles";

let router = new KoaRouter();

router.post("/set-role", verifySession(), async (ctx: SessionContext, next) => {
    let userId = ctx.session!.getUserId();

    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    // highlight-start
    await ctx.session!.updateAccessTokenPayload(
        {roles}
    );
    // highlight-end
    
    //....
});
```

</TabItem>
<TabItem value="loopback">

```tsx
import { inject, intercept } from "@loopback/core";
import { RestBindings, MiddlewareContext, post, response } from "@loopback/rest";
import { verifySession } from "supertokens-node/recipe/session/framework/loopback";
import Session from "supertokens-node/recipe/session";
import UserRoles from "supertokens-node/recipe/userroles";

class SetRole {
    constructor(@inject(RestBindings.Http.CONTEXT) private ctx: MiddlewareContext) { }
    @post("/set-role")
    @intercept(verifySession())
    @response(200)
    async handler() {
        let userId = ((this.ctx as any).session as Session.SessionContainer).getUserId();

        let roles = (await UserRoles.getRolesForUser(userId)).roles;

        // Note that this will override any existing access token payload
        // that you may have provided earlier.
        // highlight-start
        // highlight-start
        await ((this.ctx as any).session as Session.SessionContainer).updateAccessTokenPayload(
            { roles }
        );
        // highlight-end

        //....
    }
}
```

</TabItem>
<TabItem value="nextjs">

```tsx
import { superTokensNextWrapper } from 'supertokens-node/nextjs'
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express";
import UserRoles from "supertokens-node/recipe/userroles";

// highlight-start
export default async function setRole(req: SessionRequest, res: any) {
    await superTokensNextWrapper(
        async (next) => {
            await verifySession()(req, res, next);
        },
        req,
        res
    )

    let userId = req.session!.getUserId();
    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    // highlight-start
    await req.session!.updateAccessTokenPayload(
        { roles }
    );
    // highlight-end

    //....
}
```

</TabItem>
<TabItem value="nestjs">

```tsx
import { Controller, Post, UseGuards, Request, Response, Session } from "@nestjs/common";
import { SessionContainer } from "supertokens-node/recipe/session";
// @ts-ignore
import { AuthGuard } from './auth/auth.guard';
import UserRoles from "supertokens-node/recipe/userroles";

@Controller()
export class ExampleController {
  @Post('example')
  @UseGuards(AuthGuard)
  async postExample(@Session() session: SessionContainer): Promise<boolean> {
    // highlight-start
    // For more information about "AuthGuard" and the "Session" decorator please read our NestJS guide.
    let userId = session.getUserId(); 
    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    await session.updateAccessTokenPayload(
        {roles}
    );

    // highlight-end
    //....
    return true;
  }
}
```
</TabItem>

</NodeJSFrameworkSubTabs>
</TabItem>
<TabItem value="go">
<GoFrameworkSubTabs>
<TabItem value="http">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	http.ListenAndServe("SERVER ADDRESS", corsMiddleware(
		supertokens.Middleware(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
			// Handle your APIs..
			if r.URL.Path == "/set-role" && r.Method == "POST" {
				// Calling the API with session verification
				session.VerifySession(nil, setRole).ServeHTTP(rw, r)
				return
			}
		}))))
}

func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(response http.ResponseWriter, r *http.Request) {
		// from previous step...
	})
}

func setRole(w http.ResponseWriter, r *http.Request) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(r.Context())
	userId := sessionContainer.GetUserID()
	response, err := userroles.GetRolesForUser(userId, nil)
	if err != nil {
		// TODO: Handle error
		return
	}
	// highlight-start
	err = sessionContainer.UpdateAccessTokenPayload(map[string]interface{}{
		"roles": response.OK.Roles,
	})
	// highlight-end
	if err != nil {
		// TODO: Handle error
		return
	}

	// ...
}
```

</TabItem>
<TabItem value="gin">

```go
import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
)

func main() {
	router := gin.New()

	router.POST("/set-role", verifySession(nil), setRole)
}

// Wrap session.VerifySession to work with Gin
func verifySession(options *sessmodels.VerifySessionOptions) gin.HandlerFunc {
	return func(c *gin.Context) {
		session.VerifySession(options, func(rw http.ResponseWriter, r *http.Request) {
			c.Request = c.Request.WithContext(r.Context())
			c.Next()
		})(c.Writer, c.Request)
		// we call Abort so that the next handler in the chain is not called, unless we call Next explicitly
		c.Abort()
	}
}

// This is the API handler.
func setRole(c *gin.Context) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(c.Request.Context())
	userId := sessionContainer.GetUserID()
	response, err := userroles.GetRolesForUser(userId, nil)
	if err != nil {
		// TODO: Handle error
		return
	}
	// highlight-start
	err = sessionContainer.UpdateAccessTokenPayload(map[string]interface{}{
		"roles": response.OK.Roles,
	})
	// highlight-end
	if err != nil {
		// TODO: Handle error
		return
	}

	// ...
}
```

</TabItem>
<TabItem value="chi">

```go
import (
	"net/http"

	"github.com/go-chi/chi"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
)

func main() {
	r := chi.NewRouter()

	r.Post("/set-role", session.VerifySession(nil, setRole))
}

// This is the API handler.
func setRole(w http.ResponseWriter, r *http.Request) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(r.Context())
	userId := sessionContainer.GetUserID()
	response, err := userroles.GetRolesForUser(userId, nil)
	if err != nil {
		// TODO: Handle error
		return
	}
	// highlight-start
	err = sessionContainer.UpdateAccessTokenPayload(map[string]interface{}{
		"roles": response.OK.Roles,
	})
	// highlight-end
	if err != nil {
		// TODO: Handle error
		return
	}

	// ...
}
```

</TabItem>
<TabItem value="mux">

```go
import (
	"net/http"

	"github.com/gorilla/mux"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
)

func main() {
	router := mux.NewRouter()

	router.HandleFunc("/set-role",
		session.VerifySession(nil, setRole)).Methods(http.MethodPost)
}

// This is the API handler.
func setRole(w http.ResponseWriter, r *http.Request) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(r.Context())
	userId := sessionContainer.GetUserID()
	response, err := userroles.GetRolesForUser(userId, nil)
	if err != nil {
		// TODO: Handle error
		return
	}
	// highlight-start
	err = sessionContainer.UpdateAccessTokenPayload(map[string]interface{}{
		"roles": response.OK.Roles,
	})
	// highlight-end
	if err != nil {
		// TODO: Handle error
		return
	}

	// ...
}
```

</TabItem>
</GoFrameworkSubTabs>
</TabItem>
<TabItem value="python">

<PythonFrameworkSubTabs>
<TabItem value="fastapi">

TODO

</TabItem>
<TabItem value="flask">

TODO

</TabItem>
<TabItem value="django">

TODO

</TabItem>
</PythonFrameworkSubTabs>

</TabItem>
</BackendSDKTabs>


## Updating roles in a session

Post session verification, you can use the `updateAccessTokenPayload` function to update the user's role:

<BackendSDKTabs>
<TabItem value="nodejs">
<NodeJSFrameworkSubTabs>
<TabItem value="express">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import express from "express";
import { SessionRequest } from "supertokens-node/framework/express";
import UserRoles from "supertokens-node/recipe/userroles";

let app = express();

app.post("/set-role", verifySession(), async (req: SessionRequest, res) => {

    let userId = req.session!.getUserId();

    // highlight-start
    // Add the "admin" role to the user
    const response = await UserRoles.addRoleToUser(userId, "admin");

    if (response.status === "UNKNOWN_ROLE_ERROR") {
        // No such role exists
        return;
    }

    // Get the updated list of roles that the user is assigned
    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    await req.session!.updateAccessTokenPayload(
        { roles }
    );
    // highlight-end

    //....
});
```
</TabItem>
<TabItem value="hapi">

```tsx
import Hapi from "@hapi/hapi";
import { verifySession } from "supertokens-node/recipe/session/framework/hapi";
import {SessionRequest} from "supertokens-node/framework/hapi";
import UserRoles from "supertokens-node/recipe/userroles";

let server = Hapi.server({ port: 8000 });

server.route({
    path: "/set-role",
    method: "post",
    options: {
        pre: [
            {
                method: verifySession()
            },
        ],
    },
    handler: async (req: SessionRequest, res) => {
        let userId = req.session!.getUserId();

        // highlight-start
        // Add the "admin" role to the user
        const response = await UserRoles.addRoleToUser(userId, "admin");

        if (response.status === "UNKNOWN_ROLE_ERROR") {
            // No such role exists
            return;
        }

        // Get the updated list of roles that the user is assigned
        let roles = (await UserRoles.getRolesForUser(userId)).roles;

        // Note that this will override any existing access token payload
        // that you may have provided earlier.
        await req.session!.updateAccessTokenPayload(
            { roles }
        );
        // highlight-end

        //....
    }
})
```
</TabItem>
<TabItem value="fastify">

```tsx
import Fastify from "fastify";
import { verifySession } from "supertokens-node/recipe/session/framework/fastify";
import { SessionRequest } from "supertokens-node/framework/fastify";
import UserRoles from "supertokens-node/recipe/userroles";

let fastify = Fastify();

fastify.post("/set-role", {
    preHandler: verifySession(),
}, async (req: SessionRequest, res) => {
    let userId = req.session!.getUserId();

    // highlight-start
    // Add the "admin" role to the user
    const response = await UserRoles.addRoleToUser(userId, "admin");

    if (response.status === "UNKNOWN_ROLE_ERROR") {
        // No such role exists
        return;
    }

    // Get the updated list of roles that the user is assigned
    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    await req.session!.updateAccessTokenPayload(
        { roles }
    );
    // highlight-end

    //....
});
```

</TabItem>
<TabItem value="awsLambda">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/awsLambda";
import { SessionEvent } from "supertokens-node/framework/awsLambda";
import UserRoles from "supertokens-node/recipe/userroles";

async function setRole(awsEvent: SessionEvent) {
    let userId = awsEvent.session!.getUserId();

    // highlight-start
    // Add the "admin" role to the user
    const response = await UserRoles.addRoleToUser(userId, "admin");

    if (response.status === "UNKNOWN_ROLE_ERROR") {
        // No such role exists
        return;
    }

    // Get the updated list of roles that the user is assigned
    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    await awsEvent.session!.updateAccessTokenPayload(
        { roles }
    );
    // highlight-end

    //....
};

exports.handler = verifySession(setRole);
```

</TabItem>
<TabItem value="koa">

```tsx
import KoaRouter from "koa-router";
import { verifySession } from "supertokens-node/recipe/session/framework/koa";
import {SessionContext} from "supertokens-node/framework/koa";
import UserRoles from "supertokens-node/recipe/userroles";

let router = new KoaRouter();

router.post("/set-role", verifySession(), async (ctx: SessionContext, next) => {
    let userId = ctx.session!.getUserId();

    // highlight-start
    // Add the "admin" role to the user
    const response = await UserRoles.addRoleToUser(userId, "admin");

    if (response.status === "UNKNOWN_ROLE_ERROR") {
        // No such role exists
        return;
    }

    // Get the updated list of roles that the user is assigned
    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    await ctx.session!.updateAccessTokenPayload(
        {roles}
    );
    // highlight-end
    
    //....
});
```

</TabItem>
<TabItem value="loopback">

```tsx
import { inject, intercept } from "@loopback/core";
import { RestBindings, MiddlewareContext, post, response } from "@loopback/rest";
import { verifySession } from "supertokens-node/recipe/session/framework/loopback";
import Session from "supertokens-node/recipe/session";
import UserRoles from "supertokens-node/recipe/userroles";

class SetRole {
    constructor(@inject(RestBindings.Http.CONTEXT) private ctx: MiddlewareContext) { }
    @post("/set-role")
    @intercept(verifySession())
    @response(200)
    async handler() {
        let userId = ((this.ctx as any).session as Session.SessionContainer).getUserId();

        // highlight-start
        // Add the "admin" role to the user
        const response = await UserRoles.addRoleToUser(userId, "admin");

        if (response.status === "UNKNOWN_ROLE_ERROR") {
            // No such role exists
            return;
        }

        // Get the updated list of roles that the user is assigned
        let roles = (await UserRoles.getRolesForUser(userId)).roles;

        // Note that this will override any existing access token payload
        // that you may have provided earlier.
        await ((this.ctx as any).session as Session.SessionContainer).updateAccessTokenPayload(
            { roles }
        );
        // highlight-end

        //....
    }
}
```

</TabItem>
<TabItem value="nextjs">

```tsx
import { superTokensNextWrapper } from 'supertokens-node/nextjs'
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express";
import UserRoles from "supertokens-node/recipe/userroles";

// highlight-start
export default async function setRole(req: SessionRequest, res: any) {
    await superTokensNextWrapper(
        async (next) => {
            await verifySession()(req, res, next);
        },
        req,
        res
    )

    let userId = req.session!.getUserId();

    // highlight-start
    // Add the "admin" role to the user
    const response = await UserRoles.addRoleToUser(userId, "admin");

    if (response.status === "UNKNOWN_ROLE_ERROR") {
        // No such role exists
        return;
    }

    // Get the updated list of roles that the user is assigned
    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    await req.session!.updateAccessTokenPayload(
        { roles }
    );
    // highlight-end

    //....
}
```

</TabItem>
<TabItem value="nestjs">

```tsx
import { Controller, Post, UseGuards, Request, Response, Session } from "@nestjs/common";
import { SessionContainer } from "supertokens-node/recipe/session";
// @ts-ignore
import { AuthGuard } from './auth/auth.guard';
import UserRoles from "supertokens-node/recipe/userroles";

@Controller()
export class ExampleController {
  @Post('example')
  @UseGuards(AuthGuard)
  async postExample(@Session() session: SessionContainer): Promise<boolean> {
    // For more information about "AuthGuard" and the "Session" decorator please read our NestJS guide.
    let userId = session.getUserId(); 

    // highlight-start
    // Add the "admin" role to the user
    const response = await UserRoles.addRoleToUser(userId, "admin");

    if (response.status === "UNKNOWN_ROLE_ERROR") {
        // No such role exists
        return;
    }

    // Get the updated list of roles that the user is assigned
    let roles = (await UserRoles.getRolesForUser(userId)).roles;

    // Note that this will override any existing access token payload
    // that you may have provided earlier.
    await session.updateAccessTokenPayload(
        {roles}
    );

    // highlight-end
    //....
    return true;
  }
}
```
</TabItem>

</NodeJSFrameworkSubTabs>
</TabItem>
<TabItem value="go">
<GoFrameworkSubTabs>
<TabItem value="http">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	http.ListenAndServe("SERVER ADDRESS", corsMiddleware(
		supertokens.Middleware(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
			// Handle your APIs..
			if r.URL.Path == "/set-role" && r.Method == "POST" {
				// Calling the API with session verification
				session.VerifySession(nil, setRole).ServeHTTP(rw, r)
				return
			}
		}))))
}

func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(response http.ResponseWriter, r *http.Request) {
		// from previous step...
	})
}

func setRole(w http.ResponseWriter, r *http.Request) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(r.Context())
	userId := sessionContainer.GetUserID()

	// Add the "admin" role to the user
	response1, err := userroles.AddRoleToUser(userId, "admin", nil)
	if err != nil {
		// TODO: Handle error
		return
	}

	if response1.UnknownRoleError != nil {
		// No such role exists
		return
	}

	response2, err := userroles.GetRolesForUser(userId, nil)
	if err != nil {
		// TODO: Handle error
		return
	}
	err = sessionContainer.UpdateAccessTokenPayload(map[string]interface{}{
		"roles": response2.OK.Roles,
	})
	if err != nil {
		// TODO: Handle error
		return
	}

	// ...
}
```

</TabItem>
<TabItem value="gin">

```go
import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
)

func main() {
	router := gin.New()

	router.POST("/set-role", verifySession(nil), setRole)
}

// Wrap session.VerifySession to work with Gin
func verifySession(options *sessmodels.VerifySessionOptions) gin.HandlerFunc {
	return func(c *gin.Context) {
		session.VerifySession(options, func(rw http.ResponseWriter, r *http.Request) {
			c.Request = c.Request.WithContext(r.Context())
			c.Next()
		})(c.Writer, c.Request)
		// we call Abort so that the next handler in the chain is not called, unless we call Next explicitly
		c.Abort()
	}
}

// This is the API handler.
func setRole(c *gin.Context) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(c.Request.Context())
	userId := sessionContainer.GetUserID()

	// Add the "admin" role to the user
	response1, err := userroles.AddRoleToUser(userId, "admin", nil)
	if err != nil {
		// TODO: Handle error
		return
	}

	if response1.UnknownRoleError != nil {
		// No such role exists
		return
	}

	response2, err := userroles.GetRolesForUser(userId, nil)
	if err != nil {
		// TODO: Handle error
		return
	}
	err = sessionContainer.UpdateAccessTokenPayload(map[string]interface{}{
		"roles": response2.OK.Roles,
	})
	if err != nil {
		// TODO: Handle error
		return
	}

	// ...
}
```

</TabItem>
<TabItem value="chi">

```go
import (
	"net/http"

	"github.com/go-chi/chi"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
)

func main() {
	r := chi.NewRouter()

	r.Post("/set-role", session.VerifySession(nil, setRole))
}

// This is the API handler.
func setRole(w http.ResponseWriter, r *http.Request) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(r.Context())
	userId := sessionContainer.GetUserID()

	// Add the "admin" role to the user
	response1, err := userroles.AddRoleToUser(userId, "admin", nil)
	if err != nil {
		// TODO: Handle error
		return
	}

	if response1.UnknownRoleError != nil {
		// No such role exists
		return
	}

	response2, err := userroles.GetRolesForUser(userId, nil)
	if err != nil {
		// TODO: Handle error
		return
	}
	err = sessionContainer.UpdateAccessTokenPayload(map[string]interface{}{
		"roles": response2.OK.Roles,
	})
	if err != nil {
		// TODO: Handle error
		return
	}

	// ...
}
```

</TabItem>
<TabItem value="mux">

```go
import (
	"net/http"

	"github.com/gorilla/mux"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
)

func main() {
	router := mux.NewRouter()

	router.HandleFunc("/set-role",
		session.VerifySession(nil, setRole)).Methods(http.MethodPost)
}

// This is the API handler.
func setRole(w http.ResponseWriter, r *http.Request) {
	// Fetching the session object and reading the userID
	sessionContainer := session.GetSessionFromRequestContext(r.Context())
	userId := sessionContainer.GetUserID()

	// Add the "admin" role to the user
	response1, err := userroles.AddRoleToUser(userId, "admin", nil)
	if err != nil {
		// TODO: Handle error
		return
	}

	if response1.UnknownRoleError != nil {
		// No such role exists
		return
	}

	response2, err := userroles.GetRolesForUser(userId, nil)
	if err != nil {
		// TODO: Handle error
		return
	}
	err = sessionContainer.UpdateAccessTokenPayload(map[string]interface{}{
		"roles": response2.OK.Roles,
	})
	if err != nil {
		// TODO: Handle error
		return
	}

	// ...
}
```

</TabItem>
</GoFrameworkSubTabs>
</TabItem>
<TabItem value="python">

<PythonFrameworkSubTabs>
<TabItem value="fastapi">

TODO

</TabItem>
<TabItem value="flask">

TODO

</TabItem>
<TabItem value="django">

TODO

</TabItem>
</PythonFrameworkSubTabs>

</TabItem>
</BackendSDKTabs>
